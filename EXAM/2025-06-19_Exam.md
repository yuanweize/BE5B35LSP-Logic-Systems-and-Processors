# LSPè€ƒè¯• 2025å¹´6æœˆ19æ—¥

## è€ƒè¯•ä¿¡æ¯
- æ—¥æœŸï¼š2025å¹´6æœˆ19æ—¥
- è¯­è¨€ï¼šæ·å…‹è¯­
- ç±»å‹ï¼šæ ‡å‡†è€ƒè¯•
- **âœ… å·²æ ¸å¯¹PDFå®˜æ–¹ç­”æ¡ˆ**

---

## ç¬¬1é¢˜ - RSé”å­˜å™¨ä»¿çœŸ (RS Latch Simulation) (5åˆ†)
**é¢˜ç›®ï¼š** è¾“å…¥Aã€Bã€Cåœ¨æ—¶é—´t0åˆ°t4çš„å€¼å¦‚å›¾æ‰€ç¤ºã€‚å†™å‡ºXå’ŒYè¾“å‡ºçš„å€¼ã€‚
**[English]** Inputs A, B, C had values shown in the figure at times t0 to t4. Write the values of X and Y outputs.

**è¾“å…¥åºåˆ—ï¼š**
```
A = 0 | 1 | 0 | 1 | 1
B = 1 | 0 | 1 | 1 | 1
C = 1 | 0 | 1 | 1 | 0
    t0  t1  t2  t3  t4
```

> âœ… **å®˜æ–¹å‚è€ƒç­”æ¡ˆ (Official Answer):**
> ```
> X = 0 | 0 | 0 | 0 | 1
> Y = 1 | 0 | 1 | 1 | 0
> ```
> 
> ğŸ“ **è§£é¢˜æ­¥éª¤ï¼š**
> 1. **t0**: A=0, BÂ·C=1 â†’ Setè§¦å‘ï¼ŒYä¿æŒæˆ–å˜åŒ–
> 2. **t1**: A=1 â†’ Resetè§¦å‘
> 3. **t2**: A=0, BÂ·C=1 â†’ Set
> 4. **t3**: A=1, BÂ·C=1 â†’ å†²çªï¼Œçœ‹ä¼˜å…ˆçº§
> 5. **t4**: A=1, BÂ·C=0 â†’ ResetæŒç»­
> 
> âš ï¸ **æ³¨æ„ï¼š** éœ€è¦æ ¹æ®è€ƒå·ä¸Šçš„å…·ä½“ç”µè·¯å›¾æ¥åˆ†æï¼

---

## ç¬¬2é¢˜ - Shannonå±•å¼€ (Shannon Expansion) (6åˆ†)
**é¢˜ç›®ï¼š** å°†ç¬¬1é¢˜ç”µè·¯çš„å‡½æ•°X=f(A,B,C,X)ç”¨Shannonå±•å¼€åˆ†è§£ä¸ºï¼šX=(not X and f0(A,B,C)) or (X and f1(A,B,C))ã€‚
**[English]** Decompose the function X=f(A,B,C,X) from question 1 into the form X=(not X and f0(A,B,C)) or (X and f1(A,B,C)) using Shannon expansion.

> âœ… **å®˜æ–¹å‚è€ƒç­”æ¡ˆ (Official Answer) - å¡è¯ºå›¾ï¼š**
> ```
> f0:     B              f1:     B
>        A  0  1               A  0  1
>     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
> C 0 â”‚ 0  â”‚ 0  â”‚ 1 â”‚ 0  C 0 â”‚ 0  â”‚ 0  â”‚ 1 â”‚ 0
>   1 â”‚ 0  â”‚ 0  â”‚ 0 â”‚ 0    1 â”‚ 0  â”‚ 0  â”‚ 0 â”‚ 0
>     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
> ```
> 
> ğŸ“ **åšé¢˜æ–¹æ³•ï¼š**
> 1. ä»ç”µè·¯æ¨å¯¼ X = f(A, B, C, X)
> 2. ä»¤ X=0 æ±‚ fâ‚€ï¼Œä»¤ X=1 æ±‚ fâ‚
> 3. ç”¨å¡è¯ºå›¾è¡¨ç¤ºç»“æœï¼ˆå¿…é¡»ï¼ï¼‰
> 
> **å‡è®¾ç”µè·¯è¡¨è¾¾å¼ä¸º X = NOR(A, Y) ä¸” Y = NOR(BÂ·C, X)ï¼š**
> 
> å°†Yä»£å…¥ï¼šX = NOT(A OR Y) = NOT(A OR NOT(BÂ·C OR X))
> 
> **å¯¹Xå±•å¼€ï¼š**
> - å½“X=0æ—¶ï¼šfâ‚€(A,B,C) = NOT(A OR NOT(BÂ·C OR 0)) = NOT(A OR NOT(BÂ·C)) = NOT A Â· (BÂ·C)
> - å½“X=1æ—¶ï¼šfâ‚(A,B,C) = NOT(A OR NOT(BÂ·C OR 1)) = NOT(A OR 0) = NOT A
> 
> **Shannonå±•å¼€ç»“æœï¼š**
> ```
> X = (NOT X AND fâ‚€(A,B,C)) OR (X AND fâ‚(A,B,C))
> å…¶ä¸­ï¼š
> fâ‚€ = NOT A AND B AND C  
> fâ‚ = NOT A
> ```
> 
> ğŸ“Œ **è€ƒè¯•æŠ€å·§ï¼š** å…ˆä»ç”µè·¯æ¨å¯¼X=f(A,B,C,X)çš„å®Œæ•´è¡¨è¾¾å¼ï¼Œå†åˆ†åˆ«ä»¤X=0å’ŒX=1åŒ–ç®€ã€‚

---

## ç¬¬3é¢˜ - ç­‰ä»·é€»è¾‘å‡½æ•° (Equivalent Logic Functions) (4åˆ†)
**é¢˜ç›®ï¼š** å‹¾é€‰æ‰€æœ‰ä¸å…¶ä»–å‡½æ•°ç­‰ä»·çš„é€»è¾‘å‡½æ•°ã€‚
**[English]** Check all logic functions that have another equivalent function here.

```vhdl
y1 <= (A or B) and (not A or C);
y2 <= B or (A and C and B) or (not A and B and D);
y3 <= (not A and B) or (A and not B) or (C and B);
y4 <= (C and B) or (not A xor not B);
```

> ğŸ§  **AIå‚è€ƒè§£æ (AI Solution):**
> 
> **è§£é¢˜æ–¹æ³•ï¼šç”¨å¸ƒå°”ä»£æ•°åŒ–ç®€æˆ–çœŸå€¼è¡¨ (Boolean Algebra / Truth Table)**
> 
> **åŒ–ç®€ y1ï¼š**
> ```
> y1 = (A + B)(Ä€ + C)
>    = AÄ€ + AC + BÄ€ + BC
>    = AC + Ä€B + BC        (âˆµ AÄ€ = 0)
> ```
> 
> **åŒ–ç®€ y2ï¼š**
> ```
> y2 = B + ABC + Ä€BD
>    = B(1 + AC + Ä€D)
>    = B                    (âˆµ 1 + x = 1)
> ```
> 
> **åŒ–ç®€ y3ï¼š**
> ```
> y3 = Ä€B + ABÌ„ + CB
>    = A âŠ• B + CB           (å¼‚æˆ– XOR)
> ```
> 
> **åŒ–ç®€ y4ï¼š**
> ```
> y4 = CB + (Ä€ âŠ• BÌ„)
>    = CB + (A âŠ• B)         (âˆµ Ä€ âŠ• BÌ„ = A âŠ• B)
>    = CB + Ä€B + ABÌ„
> ```
> 
> **æ¯”è¾ƒç»“æœï¼š**
> - y1 = AC + Ä€B + BC
> - y2 = B
> - y3 = Ä€B + ABÌ„ + CB = AâŠ•B + CB
> - y4 = CB + Ä€B + ABÌ„ = AâŠ•B + CB
> 
> âœ… **ç­”æ¡ˆï¼šy3 â‰¡ y4**ï¼ˆä¸¤è€…ç­‰ä»·ï¼‰
> 
> ğŸ“Œ **è€ƒè¯•æŠ€å·§ï¼š** 
> - ä½¿ç”¨ Ä€âŠ•BÌ„ = AâŠ•B è¿™ä¸ªæ’ç­‰å¼
> - è‹¥è¡¨è¾¾å¼å¤æ‚ï¼Œå¯ç”»å¡è¯ºå›¾ (Karnaugh Map) éªŒè¯

---

## ç¬¬4é¢˜ - 8ä½å¯„å­˜å™¨è¿ç®— (8-bit Register Arithmetic) (2åˆ†)
**é¢˜ç›®ï¼š** å°†æŸè¿ç®—ç»“æœçš„ä½ä½å­˜å…¥1å­—èŠ‚å¯„å­˜å™¨ï¼Œä½œä¸º8ä½æ•°çš„åè¿›åˆ¶å€¼æ˜¯å¤šå°‘ï¼Ÿ
**[English]** If we store the lower bits of an operation result into a 1-byte register, what decimal value will it hold as an 8-bit number?

**ç­”æ¡ˆæ ¼å¼ï¼š**
- a) unsigned: ?
- b) signed: ?

> ğŸ§  **AIå‚è€ƒè§£æ (AI Solution):**
> 
> **8ä½å¯„å­˜å™¨è¿ç®—åŸç† (8-bit Arithmetic)ï¼š**
> - 8ä½æ— ç¬¦å·èŒƒå›´ï¼š0 ~ 255
> - 8ä½æœ‰ç¬¦å·èŒƒå›´ï¼š-128 ~ 127ï¼ˆè¡¥ç è¡¨ç¤ºï¼‰
> - æº¢å‡ºå¤„ç†ï¼šresult mod 256
> 
> **é€šç”¨è§£é¢˜æ­¥éª¤ï¼š**
> 1. è®¡ç®—åŸå§‹ç»“æœ R
> 2. æ— ç¬¦å·å€¼ = R mod 256
> 3. æœ‰ç¬¦å·å€¼ï¼šè‹¥ R mod 256 â‰¥ 128ï¼Œåˆ™æœ‰ç¬¦å·å€¼ = (R mod 256) - 256
> 
> **å¸¸è§ä¾‹é¢˜ï¼š**
> | è¿ç®— | ç»“æœ | mod 256 | unsigned | signed |
> |------|------|---------|----------|--------|
> | 255+253+251 | 759 | 247 | 247 | -9 |
> | 128+128 | 256 | 0 | 0 | 0 |
> | 100+100+100 | 300 | 44 | 44 | 44 |
> 
> **è¡¥ç è½¬æ¢å…¬å¼ (Two's Complement)ï¼š**
> ```
> è‹¥ unsigned_val â‰¥ 128:
>     signed_val = unsigned_val - 256
> å¦åˆ™:
>     signed_val = unsigned_val
> ```
> 
> ğŸ“Œ **æ³¨æ„ï¼š** é¢˜ç›®éœ€è¦å…·ä½“è¿ç®—è¡¨è¾¾å¼æ‰èƒ½è®¡ç®—ï¼Œè¯·æ ¹æ®è€ƒé¢˜ç»™å‡ºçš„æ•°å€¼ä»£å…¥ä¸Šè¿°æ–¹æ³•ã€‚

---

## ç¬¬5é¢˜ - Moore/Mealyè‡ªåŠ¨æœºå®šä¹‰ (Finite State Machine Definition) (3åˆ†)
**é¢˜ç›®ï¼š** è¡¥å…¨å®šä¹‰â€”â€”å¿…é¡»æ•°å­¦ä¸Šç²¾ç¡®ï¼
**[English]** Complete the definition - it must be mathematically precise!

**å®šä¹‰ï¼š** Automat Moore (Mealy) je uspoÅ™Ã¡danÃ¡ Å¡estice M = < X, S, Z, Ï‰, Î´, sâ‚€âˆˆS >

- **X** æ˜¯æœ‰é™è¾“å…¥å­—æ¯è¡¨ / is a finite input alphabet
- **S** æ˜¯æœ‰é™çŠ¶æ€é›†åˆ / is a finite set of states
- **Z** æ˜¯æœ‰é™è¾“å‡ºå­—æ¯è¡¨ / is a finite output alphabet
- **Î´** æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•° / is the state transition functionï¼šMoore: SÃ—Xâ†’Sï¼ŒMealy: SÃ—Xâ†’S
- **Ï‰** æ˜¯è¾“å‡ºå‡½æ•° / is the output functionï¼šMoore: Sâ†’Zï¼ŒMealy: SÃ—Xâ†’Z
- **sâ‚€** æ˜¯åˆå§‹çŠ¶æ€ / is the initial state

> ğŸ§  **AIå‚è€ƒè§£æ (AI Solution):**
> 
> **Mooreä¸Mealyè‡ªåŠ¨æœºçš„å…³é”®åŒºåˆ« (Key Differences)ï¼š**
> 
> | ç‰¹æ€§ | Moore | Mealy |
> |------|-------|-------|
> | è¾“å‡ºå‡½æ•°Ï‰ | S â†’ Z | S Ã— X â†’ Z |
> | è¾“å‡ºä¾èµ– | ä»…çŠ¶æ€ | çŠ¶æ€+è¾“å…¥ |
> | è¾“å‡ºæ—¶æœº | çŠ¶æ€å˜åŒ–å | è¾“å…¥åˆ°è¾¾æ—¶ |
> | çŠ¶æ€æ•°é‡ | é€šå¸¸æ›´å¤š | é€šå¸¸æ›´å°‘ |
> 
> **å®Œæ•´å®šä¹‰ (Complete Definition)ï¼š**
> ```
> Mooreè‡ªåŠ¨æœº: M = <X, S, Z, Î´, Ï‰, sâ‚€>
>   Î´: S Ã— X â†’ S      (çŠ¶æ€è½¬ç§»å‡½æ•°)
>   Ï‰: S â†’ Z          (è¾“å‡ºä»…å–å†³äºå½“å‰çŠ¶æ€)
> 
> Mealyè‡ªåŠ¨æœº: M = <X, S, Z, Î´, Ï‰, sâ‚€>
>   Î´: S Ã— X â†’ S      (çŠ¶æ€è½¬ç§»å‡½æ•°)  
>   Ï‰: S Ã— X â†’ Z      (è¾“å‡ºå–å†³äºå½“å‰çŠ¶æ€å’Œè¾“å…¥)
> ```
> 
> **è®°å¿†å£è¯€ï¼š**
> - Moore = "More states" â†’ è¾“å‡ºåªçœ‹çŠ¶æ€
> - Mealy = "More efficient" â†’ è¾“å‡ºçœ‹çŠ¶æ€+è¾“å…¥
> 
> ğŸ“Œ **è€ƒè¯•é‡ç‚¹ï¼š** å¿…é¡»ç²¾ç¡®å†™å‡ºÎ´å’ŒÏ‰çš„å®šä¹‰åŸŸå’Œå€¼åŸŸï¼

---

## ç¬¬6é¢˜ - åŠ æ³•å™¨è®¾è®¡ (Incrementer Design) (7åˆ†)
**é¢˜ç›®ï¼š** åŠ æ³•å™¨å¯ä»¥ä¸ç”¨å…¨åŠ å™¨ï¼Œç”¨é—¨ç”µè·¯æ›´ç®€å•åœ°å®ç°ã€‚ç”»å‡ºç”±é—¨ç»„æˆçš„ç”µè·¯å›¾ã€‚
**[English]** The adder can be implemented much simpler using gates without a full adder. Draw its schematic composed of gates.

> ğŸ§  **AIå‚è€ƒè§£æ (AI Solution):**
> 
> **+1åŠ æ³•å™¨ (Incrementer) çš„è®¾è®¡åŸç†ï¼š**
> 
> å¯¹äºnä½+1åŠ æ³•å™¨ï¼Œæ— éœ€å…¨åŠ å™¨ï¼Œåªéœ€XORå’ŒANDé—¨ï¼š
> 
> **å…¬å¼æ¨å¯¼ (Formula Derivation)ï¼š**
> ```
> sâ‚€ = xâ‚€ âŠ• 1 = NOT xâ‚€
> sâ‚ = xâ‚ âŠ• xâ‚€
> sâ‚‚ = xâ‚‚ âŠ• (xâ‚ Â· xâ‚€)
> sâ‚ƒ = xâ‚ƒ âŠ• (xâ‚‚ Â· xâ‚ Â· xâ‚€)
> ...
> sâ‚™ = xâ‚™ âŠ• (xâ‚™â‚‹â‚ Â· xâ‚™â‚‹â‚‚ Â· ... Â· xâ‚€)
> ```
> 
> **è¿›ä½è¾“å‡º (Carry Out)ï¼š**
> ```
> Cout = xâ‚ƒ Â· xâ‚‚ Â· xâ‚ Â· xâ‚€  (å½“æ‰€æœ‰ä½éƒ½ä¸º1æ—¶äº§ç”Ÿè¿›ä½)
> ```
> 
> **4ä½+1åŠ æ³•å™¨ç”µè·¯å›¾ï¼š**
> ```
>          xâ‚ƒ    xâ‚‚    xâ‚    xâ‚€
>           â”‚     â”‚     â”‚     â”‚
>           â”‚     â”‚     â”‚    â”Œâ”´â”
>           â”‚     â”‚     â”‚    â”‚Nâ”‚â”€â”€â–º sâ‚€
>           â”‚     â”‚     â”‚    â””â”€â”˜
>           â”‚     â”‚    â”Œâ”´â”
>           â”‚     â”‚    â”‚Xâ”œâ”€â”€â”€â–º sâ‚
>           â”‚     â”‚    â”‚Oâ”‚
>           â”‚     â”‚    â””â”¬â”˜
>           â”‚     â”‚     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”
>           â”‚    â”Œâ”´â”   â”Œâ”´â”       â”‚
>           â”‚    â”‚Xâ”œâ”€â”€â”€â”¤&â”‚       â”‚
>           â”‚    â”‚Oâ”‚   â””â”¬â”˜       â”‚
>           â”‚    â””â”¬â”˜    â”‚        â”‚
>           â”‚     â”‚     â””â”€â”€â–º sâ‚‚  â”‚
>          â”Œâ”´â”   â”Œâ”´â”   â”Œâ”´â”      â”Œâ”´â”
>          â”‚Xâ”œâ”€â”€â”€â”¤&â”œâ”€â”€â”€â”¤&â”‚      â”‚&â”œâ”€â”€â–º Cout
>          â”‚Oâ”‚   â””â”€â”˜   â””â”€â”˜      â””â”€â”˜
>          â””â”¬â”˜
>           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º sâ‚ƒ
> ```
> 
> **æ‰€éœ€é—¨ç”µè·¯ï¼š**
> - 1ä¸ªNOTé—¨ï¼ˆæˆ–XORé—¨æ¥VCCï¼‰
> - 3ä¸ªXORé—¨
> - 3ä¸ªANDé—¨ï¼ˆçº§è”ç»“æ„ï¼‰
> 
> ğŸ“Œ **è€ƒè¯•æŠ€å·§ï¼š** è®°ä½æ¨¡å¼ `sáµ¢ = xáµ¢ XOR (è¿›ä½é“¾)`ï¼Œè¿›ä½é“¾æ˜¯æ‰€æœ‰ä½ä½çš„AND

---

## ç¬¬7é¢˜ - VHDLä½æ“ä½œ (VHDL Bit Manipulation) (7åˆ†)
**é¢˜ç›®ï¼š** ç”¨å¹¶å‘ï¼ˆconcurrentï¼‰VHDLä»£ç æœ€ä¼˜åœ°æè¿°å›¾ä¸­ç”µè·¯ï¼Œä¸ä½¿ç”¨é¡ºåºè¯­å¥ã€‚æ•´ä¸ªæ¶æ„åªç”¨ä¸€æ¡è¯­å¥å¯å¾—æ»¡åˆ†ï¼Œæ¯å¤šä¸€æ¡æ‰£1åˆ†ã€‚
**[English]** Optimally describe the circuit in the figure using concurrent VHDL code without sequential statements. Full points for using only one statement in the architecture block; one point deducted for each additional statement.

```vhdl
library ieee; use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity Test20250619q7 is 
  port(x: in std_logic_vector(3 downto 0);
       y: out std_logic_vector(3 downto 0));
end entity;
architecture rtl of Test20250619q7 is
begin
  -- å¡«å†™ä»£ç 
end architecture rtl;
```

> ğŸ§  **AIå‚è€ƒè§£æ (AI Solution):**
> 
> **å¸¸è§å•è¡ŒVHDLè§£ç­”æ¨¡å¼ (Common Single-Statement Patterns)ï¼š**
> 
> **1. Grayç è½¬æ¢å™¨ (Gray Code Converter)ï¼š**
> ```vhdl
> y <= ('0' & x(3 downto 1)) xor x;
> ```
> è§£é‡Šï¼šå³ç§»ä¸€ä½åä¸åŸå€¼å¼‚æˆ– = Binary to Gray
> 
> **2. ä½ç¿»è½¬ (Bit Reversal)ï¼š**
> ```vhdl
> y <= x(0) & x(1) & x(2) & x(3);
> ```
> 
> **3. å¾ªç¯å·¦ç§» (Rotate Left)ï¼š**
> ```vhdl
> y <= x(2 downto 0) & x(3);
> ```
> 
> **4. å¾ªç¯å³ç§» (Rotate Right)ï¼š**
> ```vhdl
> y <= x(0) & x(3 downto 1);
> ```
> 
> **5. å–å (Invert)ï¼š**
> ```vhdl
> y <= not x;
> ```
> 
> **6. ç¬¦å·æ‰©å±• (Sign Extension)ï¼š**
> ```vhdl
> y <= (others => x(3));  -- å…¨éƒ¨å¡«å……ç¬¦å·ä½
> ```
> 
> **VHDLæ“ä½œç¬¦ä¼˜å…ˆçº§ (Operator Precedence)ï¼š**
> | ä¼˜å…ˆçº§ | æ“ä½œç¬¦ |
> |--------|--------|
> | æœ€é«˜ | not, abs |
> | | *, /, mod, rem |
> | | +, -, & |
> | | =, /=, <, >, <=, >= |
> | | and, or, xor, nand, nor, xnor |
> 
> ğŸ“Œ **è€ƒè¯•æŠ€å·§ï¼š** è§‚å¯Ÿç”µè·¯è¾“å…¥è¾“å‡ºå…³ç³»ï¼Œæ‰¾å‡ºä½æ“ä½œæ¨¡å¼ï¼ˆç§»ä½ã€å¼‚æˆ–ã€æ‹¼æ¥ç­‰ï¼‰

---

## ç¬¬8é¢˜ - VHDLç”µè·¯åˆ†æ (VHDL Circuit Analysis) (7+1åˆ†)
**é¢˜ç›®ï¼š** æ ¹æ®ä»¥ä¸‹ä»£ç ï¼Œä½¿ç”¨é—¨ã€å¤šè·¯é€‰æ‹©å™¨ã€+1åŠ æ³•å™¨ã€æ¯”è¾ƒå™¨å’ŒDFFå¯„å­˜å™¨çš„ç¬¦å·ç”»å‡ºæ–¹æ¡†å›¾ã€‚
**[English]** Draw the block diagram for the circuit described by the following code, using symbols for gates, multiplexor, +1 adder, comparator, and DFF registers.

> ğŸ§  **AIå‚è€ƒè§£æ (AI Solution):**
> 
> **VHDLåˆ°æ–¹æ¡†å›¾çš„æ˜ å°„è§„åˆ™ (VHDL to Block Diagram Mapping)ï¼š**
> 
> | VHDLä»£ç  | å¯¹åº”å…ƒä»¶ |
> |----------|----------|
> | `if rising_edge(clk)` | DFFå¯„å­˜å™¨ (D Flip-Flop) |
> | `when...else` / `with...select` | å¤šè·¯é€‰æ‹©å™¨ (MUX) |
> | `x + 1` | +1åŠ æ³•å™¨ (Incrementer) |
> | `x = y` / `x < y` | æ¯”è¾ƒå™¨ (Comparator) |
> | `and`/`or`/`not` | é€»è¾‘é—¨ (Logic Gates) |
> 
> **å¸¸è§ç”µè·¯æ¨¡å¼è¯†åˆ«ï¼š**
> 
> **1. è®¡æ•°å™¨ (Counter)ï¼š**
> ```vhdl
> process(clk)
> begin
>   if rising_edge(clk) then
>     if cnt = MAX then cnt <= 0;
>     else cnt <= cnt + 1;
>     end if;
>   end if;
> end process;
> ```
> å…ƒä»¶ï¼šDFF + +1åŠ æ³•å™¨ + æ¯”è¾ƒå™¨ + MUX
> 
> **2. ç§»ä½å¯„å­˜å™¨ (Shift Register)ï¼š**
> ```vhdl
> process(clk)
> begin
>   if rising_edge(clk) then
>     reg <= reg(N-2 downto 0) & din;
>   end if;
> end process;
> ```
> å…ƒä»¶ï¼šçº§è”DFF
> 
> **3. çŠ¶æ€æœº (FSM)ï¼š**
> ```vhdl
> process(clk)
> begin
>   if rising_edge(clk) then
>     state <= next_state;
>   end if;
> end process;
> ```
> å…ƒä»¶ï¼šDFFï¼ˆçŠ¶æ€å¯„å­˜å™¨ï¼‰+ ç»„åˆé€»è¾‘
> 
> **ç”»å›¾æ­¥éª¤ (Drawing Steps)ï¼š**
> 1. æ‰¾å‡ºæ‰€æœ‰æ—¶åºå…ƒä»¶ï¼ˆæœ‰`rising_edge`çš„ä¿¡å·ï¼‰â†’ ç”»DFF
> 2. è¯†åˆ«ç®—æœ¯è¿ç®— â†’ ç”»åŠ æ³•å™¨/æ¯”è¾ƒå™¨
> 3. è¯†åˆ«é€‰æ‹©ç»“æ„ â†’ ç”»MUX
> 4. è¿æ¥æ‰€æœ‰å…ƒä»¶ï¼Œæ ‡æ³¨ä¿¡å·å
> 
> ğŸ“Œ **æ³¨æ„ï¼š** å…·ä½“ç­”æ¡ˆéœ€è¦çœ‹é¢˜ç›®ç»™å‡ºçš„VHDLä»£ç 

---

## ç¬¬9é¢˜ - åˆ†æ”¯é¢„æµ‹ (Branch Prediction) (8åˆ†)

> ğŸ›‘ **éè€ƒç‚¹æç¤º (Not on Exam):** æ ¹æ®2026å¹´1æœˆè€ƒè¯•è¯´æ˜ï¼Œåˆ†æ”¯é¢„æµ‹å™¨æœ¬æ¬¡ä¸è€ƒï¼Œå¯æˆ˜ç•¥æ€§è·³è¿‡ã€‚

**é¢˜ç›®ï¼š** Cç¨‹åºå¤„ç†æŸæ•°æ®ã€‚å‡è®¾forå¾ªç¯ç¼–è¯‘ä¸ºdo-whileå½¢å¼ï¼Œå¤„ç†å™¨ä½¿ç”¨ä»¥ä¸‹é¢„æµ‹å™¨ï¼Œè®¡ç®—åˆ†æ”¯é¢„æµ‹é”™è¯¯æ¬¡æ•°ã€‚
**[English]** A C program processes data. Assuming the for-loop is compiled as do-while and the processor uses the following predictors, calculate the number of branch mispredictions.

**ç­”æ¡ˆï¼š**
- 1ä½é¢„æµ‹å™¨ï¼ˆåˆå§‹NTï¼‰: misses = ?
- 2ä½é¢„æµ‹å™¨ï¼ˆåˆå§‹WTï¼‰: misses = ?

> ğŸ§  **AIå‚è€ƒè§£æ (AI Solution):**
> 
> **åˆ†æ”¯é¢„æµ‹å™¨åŸç† (Branch Predictor Principles)ï¼š**
> 
> **1ä½é¢„æµ‹å™¨ (1-bit Predictor)ï¼š**
> - çŠ¶æ€ï¼šT (Taken) æˆ– NT (Not Taken)
> - è§„åˆ™ï¼šé¢„æµ‹é”™è¯¯å°±ç¿»è½¬çŠ¶æ€
> - åˆå§‹NTï¼šç¬¬ä¸€æ¬¡è·³è½¬å¿…é”™
> 
> **2ä½é¢„æµ‹å™¨ (2-bit Saturating Counter)ï¼š**
> | çŠ¶æ€ | é¢„æµ‹ | Tæ—¶ | NTæ—¶ |
> |------|------|-----|------|
> | ST (Strongly Taken) | T | ST | WT |
> | WT (Weakly Taken) | T | ST | WN |
> | WN (Weakly Not-Taken) | NT | WT | SN |
> | SN (Strongly Not-Taken) | NT | WN | SN |
> 
> **å¸¸è§å¾ªç¯æ¨¡å¼åˆ†æï¼š**
> 
> **å¤–å¾ªç¯Næ¬¡ï¼Œå†…å¾ªç¯Mæ¬¡ï¼š**
> ```c
> for (i=0; i<N; i++)      // å¤–å¾ªç¯ï¼šNæ¬¡T + 1æ¬¡NT
>   for (j=0; j<M; j++)    // å†…å¾ªç¯ï¼šæ¯è½®Mæ¬¡T + 1æ¬¡NTï¼Œå…±Nè½®
> ```
> 
> **1ä½é¢„æµ‹å™¨ missè®¡ç®—ï¼š**
> - å¤–å¾ªç¯ï¼šé¦–æ¬¡å…¥å¾ªç¯miss + æœ€åé€€å‡ºmiss = 2æ¬¡
> - å†…å¾ªç¯ï¼šæ¯è½®é¦–æ¬¡miss + æ¯è½®é€€å‡ºmiss = NÃ—2æ¬¡
> - **æ€»è®¡ï¼š2 + 2Næ¬¡miss**
> 
> **2ä½é¢„æµ‹å™¨ï¼ˆåˆå§‹WTï¼‰missè®¡ç®—ï¼š**
> - å¤–å¾ªç¯ï¼šæœ€åé€€å‡ºmiss = 1æ¬¡
> - å†…å¾ªç¯ï¼šæ¯è½®é€€å‡ºä»STâ†’WTä¸ç®—missï¼Œæœ€åé€€å‡ºæ‰miss
> - è§„å¾‹ï¼šå†…å¾ªç¯æ¯è½®é€€å‡ºæ—¶1æ¬¡miss
> - **æ€»è®¡ï¼š1 + Næ¬¡miss**ï¼ˆçº¦ä¸º1ä½çš„ä¸€åŠï¼‰
> 
> **å…¸å‹ä¾‹é¢˜ï¼ši<5, j<2000**
> - 1ä½ï¼š2 + 2Ã—5 = 12æ¬¡miss
> - 2ä½ï¼š1 + 5 = 6æ¬¡miss
> 
> **æŸ¥æ‰¾æœ€å°å€¼ç¨‹åºåˆ†æï¼š**
> ```c
> for (i=1; i<n; i++)
>   if (a[i] < min) min = a[i];  // æ¡ä»¶åˆ†æ”¯
> ```
> - å¤–å¾ªç¯ï¼šåŒä¸Š
> - ifåˆ†æ”¯ï¼šå–å†³äºæ•°æ®ï¼Œå¹³å‡çº¦logâ‚‚(n)æ¬¡æ›´æ–°
> 
> ğŸ“Œ **è€ƒè¯•æŠ€å·§ï¼š** ç”»å‡ºé¢„æµ‹å™¨çŠ¶æ€è½¬ç§»å›¾ï¼Œé€æ¬¡è·Ÿè¸ªé¢„æµ‹ç»“æœ

---
