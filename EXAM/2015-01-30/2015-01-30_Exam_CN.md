# LSP Exam - 2015å¹´1æœˆ30æ—¥

> **CVUT FEL (ÄŒVUT) - ÄŒeskÃ© vysokÃ© uÄenÃ­ technickÃ© v Praze | Czech Technical University in Prague**
>
> ğŸ‡¨ğŸ‡³ [ä¸­æ–‡ç‰ˆ](2015-01-30_Exam_CN.md) | ğŸ‡¬ğŸ‡§ [English](2015-01-30_Exam_EN.md) | ğŸ‡¨ğŸ‡¿ [ÄŒeÅ¡tina](2015-01-30_Exam_CZ.md)

> ğŸ§  **AIæ¨æ¼”ç‰ˆæœ¬** - ä»¥ä¸‹ä¸ºè§£æå‚è€ƒ

---

## é¢˜ç›®1: é€»è¾‘è¡¨è¾¾å¼åŒ–ç®€ 

**é¢˜ç›®**: é‡å†™é€»è¾‘è¡¨è¾¾å¼Fï¼Œä½¿NOTè¿ç®—ç¬¦åªå‡ºç°åœ¨å˜é‡å‰é¢ï¼Œç”¨å¡è¯ºå›¾éªŒè¯ï¼
**[English]** Rewrite the logic expression F so that NOT operators only appear before variables, verify with Karnaugh map!

```
F = not ( (A or not B or not C) or ( (A or B) and not (A or not C)) )
```

### è§£ç­”æ­¥éª¤

1. åº”ç”¨å¾·æ‘©æ ¹å®šå¾‹: `not(X or Y) = not X and not Y`
2. é€æ­¥åŒ–ç®€...

```
F = not(A or BÌ„ or CÌ„) and not((A or B) and not(A or CÌ„))
  = Ä€Â·BÂ·C and (not(A or B) or (A or CÌ„))
  = Ä€Â·BÂ·C and ((Ä€Â·BÌ„) or A or CÌ„)
```

ç»§ç»­åŒ–ç®€å¾—åˆ°æœ€ç»ˆç»“æœ...

### å¡è¯ºå›¾éªŒè¯

| F | C=0 | C=1 |
|---|-----|-----|
| AB=00 | | |
| AB=01 | | |
| AB=11 | | |
| AB=10 | | |

---

## é¢˜ç›®2: RSé”å­˜å™¨ç”µè·¯ä»¿çœŸ â­å¸¸è€ƒ

**é¢˜ç›®**: è¾“å…¥A, B, Cåœ¨æ—¶åˆ»t0, t1, t2, t3çš„å€¼å¦‚ä¸‹ï¼Œå†™å‡ºQè¾“å‡ºå€¼ã€‚
**[English]** Given inputs A, B, C values at times t0, t1, t2, t3 as shown, write the Q output value.

```
A = ..0..|..1..|..1..|..1..|
B = ..0..|..0..|..0..|..1..|
C = ..1..|..1..|..0..|..0..|

t0   t1   t2   t3

Q = _____|_____|_____|_____|
```

å‡è®¾è¾“å…¥å˜åŒ–ä¹‹é—´çš„é—´éš”è¶³å¤Ÿé•¿ï¼Œå¯ä»¥å¿½ç•¥é—¨å»¶è¿Ÿã€‚

---

## é¢˜ç›®3: é¦™å†œå±•å¼€ â­å¸¸è€ƒ

**é¢˜ç›®**: å°†é¢˜ç›®2ä¸­çš„å‡½æ•° `Q=f(A,B,C,Q)` åˆ†è§£ä¸ºï¼š
**[English]** Decompose the function Q=f(A,B,C,Q) from question 2 into:

```
Q = (not Q and f0(A,B,C)) or (Q and f1(A,B,C))
```

å†™å‡ºf0å’Œf1çš„å¡è¯ºå›¾ã€‚

### è§£é¢˜æ–¹æ³•
1. ä»¤Q=0ï¼Œæ±‚f0
2. ä»¤Q=1ï¼Œæ±‚f1
3. ç”»å¡è¯ºå›¾

---

## é¢˜ç›®4: æœ‰ç¬¦å·/æ— ç¬¦å·æ•°ä½å€¼ â­å¸¸è€ƒ

**é¢˜ç›®**: 10ä½äºŒè¿›åˆ¶æ•° `10 0000 1111` çš„åè¿›åˆ¶å€¼æ˜¯å¤šå°‘ï¼Ÿ
**[English]** What is the decimal value of the 10-bit binary number 10 0000 1111?

a) **æ— ç¬¦å·æ•°(unsigned)**: ____________________

b) **æœ‰ç¬¦å·æ•°(two's-complement)**: ____________________

### è§£ç­”

```
10 0000 1111 (äºŒè¿›åˆ¶)

a) æ— ç¬¦å·: 
   = 2^9 + 2^3 + 2^2 + 2^1 + 2^0 
   = 512 + 8 + 4 + 2 + 1 
   = 527

b) æœ‰ç¬¦å·(è¡¥ç ): 
   æœ€é«˜ä½æ˜¯1ï¼Œè¡¨ç¤ºè´Ÿæ•°
   æ–¹æ³•1: = -2^9 + (å‰©ä½™ä½çš„å€¼)
        = -512 + 15 = -497
   
   æ–¹æ³•2: å–ååŠ 1
        01 1111 0000 + 1 = 01 1111 0001 = 497
        æ‰€ä»¥åŸæ•° = -497
```

---

## é¢˜ç›®5: ç­‰ä»·é€»è¾‘å‡½æ•° â­å¸¸è€ƒ

**é¢˜ç›®**: æ ‡è®°æ‰€æœ‰ä¸å…¶ä»–å‡½æ•°ç­‰ä»·çš„é€»è¾‘å‡½æ•°ï¼š
**[English]** Mark all logic functions that are equivalent to other functions:

```vhdl
f1 <= (A xor C) or (A and not C);
f2 <= (B or C) and (not A or B or C);
f3 <= ((C and not B) or (B and A));
f4 <= (A or C) and (not A or not C);
f5 <= (A and not B) xor (A and C);
f6 <= (A and not C) or (C and not A);
```

### è§£é¢˜æ–¹æ³•
ç”»å‡ºæ¯ä¸ªå‡½æ•°çš„å¡è¯ºå›¾ï¼š

**f1**: (A xor C) or (A and not C) = A or (A xor C) = A or CÌ„Â·C... 

**f4**: (A or C) and (not A or not C) = AâŠ•C

**f6**: (A and not C) or (C and not A) = AâŠ•C

**ç»“è®º**: f4 â‰¡ f6 (éƒ½æ˜¯ A XOR C)

---

## é¢˜ç›®6: RSé”å­˜å™¨ç”»å›¾ â­å¸¸è€ƒ

**é¢˜ç›®**: ä»…ä½¿ç”¨NORé—¨ç”»å‡ºRSé”å­˜å™¨ï¼Œä»…ä½¿ç”¨NANDé—¨ç”»å‡ºRSé”å­˜å™¨ã€‚
**[English]** Draw RS latch using only NOR gates, and draw RS latch using only NAND gates.

### NORå‹ RSé”å­˜å™¨ (é«˜ç”µå¹³æœ‰æ•ˆ)
```
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
S â”€â”€â”€â”¤>    NOR     â”œâ”€â”€â”€â”¬â”€â”€â”€ Q
     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â”‚
            â”‚          â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”   â”‚
     â”‚             â”‚   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”˜
                   â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
R â”€â”€â”€â”¤>    NOR     â”œâ”€â”€â”€â”¬â”€â”€â”€ QÌ„
     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â”‚
            â”‚          â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### NANDå‹ RSé”å­˜å™¨ (ä½ç”µå¹³æœ‰æ•ˆ)
```
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
SÌ„ â”€â”€â”€â”¤>   NAND     â”œâ”€â”€â”€â”¬â”€â”€â”€ Q
     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â”‚
            â”‚          â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”   â”‚
     â”‚             â”‚   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”˜
                   â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
RÌ„ â”€â”€â”€â”¤>   NAND     â”œâ”€â”€â”€â”¬â”€â”€â”€ QÌ„
     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â”‚
            â”‚          â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## é¢˜ç›®7: å¼‚æ­¥18åˆ†é¢‘å™¨è®¾è®¡

**é¢˜ç›®**: åœ¨æœªå®Œæˆçš„å›¾ä¸­æ·»åŠ é—¨å’Œè¿çº¿ï¼Œåˆ›å»ºCLKæ—¶é’Ÿä¿¡å·çš„**18åˆ†é¢‘**å¼‚æ­¥åˆ†é¢‘å™¨ï¼Œå¸¦å¼‚æ­¥å¤ä½ACLRNã€‚
**[English]** Add gates and connections to the incomplete diagram to create an asynchronous divide-by-18 divider of CLK clock signal with asynchronous reset ACLRN.

### è®¾è®¡æ€è·¯
- 18åˆ†é¢‘éœ€è¦è®¡æ•°0-17ï¼Œå…±18ä¸ªçŠ¶æ€
- 17çš„äºŒè¿›åˆ¶: 10001
- æ£€æµ‹åˆ°17æ—¶å¤ä½æ‰€æœ‰è§¦å‘å™¨

### å…³é”®è¿æ¥
- ä½¿ç”¨5ä¸ªDè§¦å‘å™¨çº§è”
- ç”¨ANDé—¨æ£€æµ‹çŠ¶æ€10001
- æ£€æµ‹è¾“å‡ºè¿æ¥åˆ°æ‰€æœ‰DFFçš„CLRN

---

## é¢˜ç›®8: VHDLä»£ç åˆ†æ

**é¢˜ç›®**: åˆ†ææ ¼å¼é”™è¯¯çš„VHDLä»£ç ï¼Œç”»å‡ºå¯¹åº”çš„é€»è¾‘ç”µè·¯å›¾ã€‚
**[English]** Analyze the poorly formatted VHDL code and draw the corresponding logic circuit diagram.

```vhdl
library IEEE; use IEEE.STD_LOGIC_1164.all;
entity test20140214 is port (a, b, c, d : in std_logic; e : out std_logic); end;
architecture rtl of test20140214 is begin
process(a, b) variable z:std_logic_vector(0 to 3); begin
if b = '0' then z:=(others=>'0'); 
elsif rising_edge(a) then
  if c='1' then z:=d & z(0 to 2); 
  else z:=z(3) & z(0 to 2); 
  end if; 
end if; 
e<=z(3); 
end process; 
end rtl;
```

### æ ¼å¼åŒ–ä»£ç 
```vhdl
library IEEE; 
use IEEE.STD_LOGIC_1164.all;

entity test20140214 is 
    port (a, b, c, d : in std_logic; 
          e : out std_logic); 
end;

architecture rtl of test20140214 is 
begin
    process(a, b) 
        variable z: std_logic_vector(0 to 3); 
    begin
        if b = '0' then 
            z := (others => '0');     -- å¼‚æ­¥æ¸…é›¶
        elsif rising_edge(a) then
            if c = '1' then 
                z := d & z(0 to 2);   -- ä¸²è¡Œè¾“å…¥d
            else 
                z := z(3) & z(0 to 2); -- å¾ªç¯ç§»ä½
            end if; 
        end if; 
        e <= z(3); 
    end process; 
end rtl;
```

### åŠŸèƒ½åˆ†æ
- **ç”µè·¯åç§°**: 4ä½å¯æ§ç§»ä½å¯„å­˜å™¨
- **a**: æ—¶é’Ÿä¿¡å· (ä¸Šå‡æ²¿è§¦å‘)
- **b**: å¼‚æ­¥æ¸…é›¶ (b='0'æ—¶æ¸…é›¶)
- **c**: æ¨¡å¼æ§åˆ¶
  - c='1': ä¸²è¡Œè¾“å…¥æ¨¡å¼ï¼Œdè¿›å…¥z(0)
  - c='0': å¾ªç¯ç§»ä½æ¨¡å¼
- **e**: è¾“å‡ºz(3)

---

## çŸ¥è¯†ç‚¹æ€»ç»“

| é¢˜å· | é¢˜å‹ | éš¾åº¦ |
|------|------|------|
| 1 | é€»è¾‘è¡¨è¾¾å¼åŒ–ç®€ | â­â­ |
| 2 | RSé”å­˜å™¨ä»¿çœŸ | â­â­â­ |
| 3 | é¦™å†œå±•å¼€ | â­â­â­ |
| 4 | æœ‰ç¬¦å·/æ— ç¬¦å·æ•° | â­ |
| 5 | ç­‰ä»·å‡½æ•°åˆ¤æ–­ | â­â­ |
| 6 | RSé”å­˜å™¨ç”»å›¾ | â­â­ |
| 7 | åˆ†é¢‘å™¨è®¾è®¡ | â­â­â­ |
| 8 | VHDLåˆ†æ | â­â­â­ |
