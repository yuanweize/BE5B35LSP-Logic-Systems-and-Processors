# LSP Exam 2023-06-13 / ZkouÅ¡ka LSP 2023-06-13 / LSPè€ƒè¯• 2023å¹´6æœˆ13æ—¥

> **Course**: B0B35LSP - LogickÃ© systÃ©my a procesory | BE5B35LSP - Logic Systems and Processors
> **University**: CVUT FEL (ÄŒVUT) - ÄŒeskÃ© vysokÃ© uÄenÃ­ technickÃ© v Praze | Czech Technical University in Prague
> **Keywords**: LSP, Exam, ZkouÅ¡ka, 2023-06-13, logic equivalence, arithmetic, RS latch, VHDL
>
> [ğŸ‡¨ğŸ‡³ CN Version](./2023-06-13_Exam_CN.md) | [ğŸ‡¬ğŸ‡§ EN Version](./2023-06-13_Exam_EN.md) | [ğŸ‡¨ğŸ‡¿ CZ Version](./2023-06-13_Exam_CZ.md)

---

# LSPè€ƒè¯• 2023å¹´6æœˆ13æ—¥
> ğŸ§  **AIæ¨æ¼”ç‰ˆæœ¬** - æœ¬è¯•å·PDFæ— å®˜æ–¹ç­”æ¡ˆï¼Œä»¥ä¸‹ä¸ºæ¨æ¼”è§£æ

## è€ƒè¯•ä¿¡æ¯
- æ—¥æœŸï¼š2023å¹´6æœˆ13æ—¥
- è¯­è¨€ï¼šæ·å…‹è¯­
- åŒ…å«ç»Ÿè®¡æ•°æ®å›¾è¡¨
- âš ï¸ æ³¨æ„ï¼šæœ¬åœºè€ƒè¯•RSé”å­˜å™¨ä¸º4è¾“å…¥(A,B,C,D)å˜ä½“

---

## ç¬¬1é¢˜ - ç­‰ä»·é€»è¾‘å‡½æ•° (4åˆ†)
**é¢˜ç›®ï¼š** å‹¾é€‰æ‰€æœ‰å…·æœ‰ç­‰ä»·å‡½æ•°çš„é€»è¾‘å‡½æ•°ï¼š
**[English]** Check all logic functions that have an equivalent function:

```vhdl
y1 <= (D and not C) or (not C and A) or (D and B);
y2 <= (D and C) xor (B and A);
y3 <= (D or A) and (not C or B) and (D or not C);
y4 <= (D and B) or (D and not C and not B) or ((D xor A) and not C);
```

**è§£é¢˜æ–¹æ³•ï¼š** æ„å»ºå¡è¯ºå›¾æ¯”è¾ƒ

---

## ç¬¬2é¢˜ - 12ä½åŠ æ³•å™¨è¿ç®— (2åˆ†)
**é¢˜ç›®ï¼š** åœ¨12ä½äºŒè¿›åˆ¶åŠ æ³•å™¨ä¸Šæ‰§è¡Œ510+512+514+516ï¼Œç»“æœä½œä¸º12ä½æ•°ï¼š
**[English]** Perform 510+512+514+516 on a 12-bit binary adder, result as a 12-bit number:

**è®¡ç®—ï¼š**
- 510+512+514+516 = 2052
- 2052 mod 4096 = 2052ï¼ˆæœªæº¢å‡ºï¼‰
- 2052 = 0x804 = 0b100000000100

**ç­”æ¡ˆï¼š**
- a) **unsignedï¼ˆæ— ç¬¦å·ï¼‰**: 2052
- b) **signedï¼ˆäºŒè¿›åˆ¶è¡¥ç æœ‰ç¬¦å·ï¼‰**: 2052ï¼ˆæ­£æ•°ï¼Œæœªè¶…è¿‡2047ï¼‰

---

## ç¬¬3é¢˜ - RSé”å­˜å™¨ä»¿çœŸ (4åˆ†)
**é¢˜ç›®ï¼š** ç»™å®šè¾“å…¥A, B, C, Dåœ¨æ—¶é—´t0-t4çš„å€¼ï¼Œå†™å‡ºXå’ŒYè¾“å‡ºçš„å€¼
**[English]** Given inputs A, B, C, D values at times t0-t4, write the values of X and Y outputs

**è¾“å…¥åºåˆ—ï¼š**
```
A = 0 | 1 | 1 | 1 | 1
B = 0 | 0 | 1 | 0 | 0
C = 0 | 0 | 1 | 1 | 0
D = 1 | 1 | 0 | 0 | 1
    t0  t1  t2  t3  t4
```

---

## ç¬¬4é¢˜ - Shannonå±•å¼€ (8åˆ†)
**é¢˜ç›®ï¼š** å°†ç¬¬3é¢˜çš„X=f(A,B,C,D,X)åˆ†è§£ä¸ºï¼š
**[English]** Decompose X=f(A,B,C,D,X) from question 3 into:
$$X = (\overline{X} \land f_0(A,B,C,D)) \lor (X \land f_1(A,B,C,D))$$

---

## ç¬¬5é¢˜ - Moore/Mealyè‡ªåŠ¨æœºå®šä¹‰ (4åˆ†)
**é¢˜ç›®ï¼š** å®Œæˆå®šä¹‰
**[English]** Complete the definition

M = < X, S, Z, Ï‰, Î´, sâ‚€âˆˆS >

**ç­”æ¡ˆï¼š**
- **X**: æœ‰é™è¾“å…¥ç¬¦å·é›†åˆ / Finite input alphabet
- **S**: æœ‰é™çŠ¶æ€é›†åˆ / Finite set of states
- **Z**: æœ‰é™è¾“å‡ºç¬¦å·é›†åˆ / Finite output alphabet
- **Î´**: çŠ¶æ€è½¬ç§»å‡½æ•° / State transition function
  - Moore: S Ã— X â†’ S
  - Mealy: S Ã— X â†’ S
- **Ï‰**: è¾“å‡ºå‡½æ•° / Output function
  - Moore: S â†’ Z
  - Mealy: S Ã— X â†’ Z
- **sâ‚€**: åˆå§‹çŠ¶æ€ / Initial state

---

## ç¬¬6é¢˜ - RSé”å­˜å™¨è®¾è®¡ (8åˆ†)
**é¢˜ç›®ï¼š** åˆ†åˆ«ç”¨NORé—¨å’ŒNANDé—¨ç”»å‡ºRSé”å­˜å™¨ï¼Œå¹¶å®ŒæˆçœŸå€¼è¡¨
**[English]** Draw RS latch using NOR gates and NAND gates respectively, and complete the truth tables

### NORé—¨RSé”å­˜å™¨çœŸå€¼è¡¨
| S | R | Q | QN |
|---|---|---|---|
| 0 | 0 | ä¿æŒ | ä¿æŒ |
| 0 | 1 | 0 | 1 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 0 |

### NANDé—¨RSé”å­˜å™¨çœŸå€¼è¡¨
| S | R | Q | QN |
|---|---|---|---|
| 0 | 0 | 1 | 1 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | ä¿æŒ | ä¿æŒ |

---

## ç¬¬7é¢˜ - VHDLä»£ç åˆ†æ (10åˆ†)
**é¢˜ç›®ï¼š** åˆ†æä»£ç å¹¶ç”»å‡ºç”µè·¯å›¾
**[English]** Analyze the code and draw the circuit diagram

```vhdl
library IEEE; use IEEE.STD_LOGIC_1164.all;
entity xxx is port (a, b : in std_logic; q : out std_logic); end entity;
architecture rtl of xxx is 
begin 
  process(a,b) 
    variable z:std_logic_vector(0 to 3);
  begin 
    if rising_edge(b) then 
      if a= '0' then 
        z:="0001"; 
      else 
        z:=z(1 to 3) & z(0); 
      end if; 
    end if; 
    q<=z(3);
  end process; 
end rtl;
```

**åŠŸèƒ½åˆ†æï¼š**
- bä¸Šå‡æ²¿è§¦å‘
- a='0'æ—¶å¤ä½ä¸º"0001"
- a='1'æ—¶å¾ªç¯å·¦ç§»
- è¾“å‡ºz(3)
- **åç§°ï¼šå¸¦åŒæ­¥å¤ä½çš„ç¯å½¢ç§»ä½å¯„å­˜å™¨**

---

## ç¬¬8é¢˜ - VHDLç”µè·¯æè¿° (10åˆ†)
**é¢˜ç›®ï¼š** ç”¨VHDLæè¿°ç»™å®šç”µè·¯å›¾
**[English]** Describe the given circuit diagram in VHDL

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity Test2 is 
  port(ACLRN, CLK, X : in std_logic;
       Q, Q2 : out std_logic);
end entity;
architecture rtl of Test2 is
  signal q_int : std_logic;
begin
  process(ACLRN, CLK)
  begin
    if ACLRN = '0' then
      q_int <= '0';
    elsif rising_edge(CLK) then
      q_int <= X;
    end if;
  end process;
  Q <= q_int;
  Q2 <= not q_int;
end architecture rtl;
```

---

## ç¬¬9é¢˜ - é™„åŠ é¢˜ï¼šé”¯é½¿æ³¢å‘ç”Ÿå™¨ (10åˆ†)
**é¢˜ç›®ï¼š** å®ç°3ä½åŒæ­¥è®¡æ•°å™¨ï¼š0,1,2,3,4,5,6,7,6,5,4,3,2,1,0,1...
**[English]** Implement a 3-bit synchronous counter: 0,1,2,3,4,5,6,7,6,5,4,3,2,1,0,1...

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity pila is 
  port (clk : in std_logic; 
        q: out std_logic_vector(2 downto 0));
end entity;
architecture rtl of pila is
  signal cnt : unsigned(2 downto 0) := "000";
  signal dir : std_logic := '1';
begin
  process(clk)
  begin
    if rising_edge(clk) then
      if dir = '1' then
        if cnt = 7 then
          dir <= '0';
          cnt <= "110";
        else
          cnt <= cnt + 1;
        end if;
      else
        if cnt = 0 then
          dir <= '1';
          cnt <= "001";
        else
          cnt <= cnt - 1;
        end if;
      end if;
    end if;
  end process;
  q <= std_logic_vector(cnt);
end architecture;
```

---

## çŸ¥è¯†ç‚¹æ€»ç»“

### æœ¬æ¬¡è€ƒè¯•é‡ç‚¹
1. ç­‰ä»·é€»è¾‘å‡½æ•°
2. 12ä½åŠ æ³•å™¨è¿ç®—
3. RSé”å­˜å™¨ä»¿çœŸ
4. Shannonå±•å¼€
5. **Moore/Mealyè‡ªåŠ¨æœºå®šä¹‰**
6. RSé”å­˜å™¨è®¾è®¡ï¼ˆNORå’ŒNANDï¼‰
7. VHDLä»£ç åˆ†æï¼ˆç§»ä½å¯„å­˜å™¨ï¼‰
8. VHDLç”µè·¯æè¿°
9. é”¯é½¿æ³¢å‘ç”Ÿå™¨
