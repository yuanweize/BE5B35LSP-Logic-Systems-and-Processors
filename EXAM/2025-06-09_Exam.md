# LSPè€ƒè¯• 2025å¹´6æœˆ9æ—¥

## è€ƒè¯•ä¿¡æ¯
- æ—¥æœŸï¼š2025å¹´6æœˆ9æ—¥
- è¯­è¨€ï¼šæ·å…‹è¯­
- ç±»å‹ï¼šæ ‡å‡†è€ƒè¯•
- **âœ… å·²æ ¸å¯¹PDFå®˜æ–¹ç­”æ¡ˆ**

---

## ç¬¬1é¢˜ - RSé”å­˜å™¨ä»¿çœŸ (RS Latch Simulation) (5åˆ†)
**é¢˜ç›®ï¼š** è¾“å…¥Aã€Bã€Cåœ¨æ—¶é—´t0åˆ°t4çš„å€¼å¦‚å›¾æ‰€ç¤ºã€‚å†™å‡ºXå’ŒYè¾“å‡ºçš„å€¼ã€‚
**[English]** Inputs A, B, C had values shown in the figure at times t0 to t4. Write the values of X and Y outputs.

**è¾“å…¥åºåˆ—ï¼š**
```
A = 1 | 1 | 1 | 0 | 1
B = 1 | 1 | 0 | 1 | 1
C = 0 | 1 | 0 | 0 | 0
    t0  t1  t2  t3  t4
```

> âœ… **å®˜æ–¹å‚è€ƒç­”æ¡ˆ (Official Answer):**
> ```
> X = 0 | 0 | 1 | 1 | 0   (äºŒè¿›åˆ¶: 00110)
> Y = 1 | 0 | 0 | 0 | 1   (äºŒè¿›åˆ¶: 10011)
> ```

> ğŸ’¡ **è¯¦ç»†è§£æï¼š**
> - **t0**: A=1 â†’ Reset, X=0; BÂ·C=0 â†’ Y=1
> - **t1**: A=1, BÂ·C=1 â†’ Resetä¼˜å…ˆ, X=0, Y=0
> - **t2**: A=1, BÂ·C=0 â†’ Xå˜1? (éœ€çœ‹ç”µè·¯)
> - **t3**: A=0, BÂ·C=0 â†’ ä¿æŒ
> - **t4**: A=1 â†’ Reset

---

## ç¬¬2é¢˜ - Shannonå±•å¼€ (Shannon Expansion) (6åˆ†)
**é¢˜ç›®ï¼š** å°†ç¬¬1é¢˜ç”µè·¯çš„å‡½æ•°X=f(A,B,C,X)ç”¨Shannonå±•å¼€åˆ†è§£ä¸ºï¼šX=(not X and f0(A,B,C)) or (X and f1(A,B,C))ã€‚
**[English]** Decompose the function X=f(A,B,C,X) from question 1 into the form X=(not X and f0(A,B,C)) or (X and f1(A,B,C)) using Shannon expansion.

> âœ… **å®˜æ–¹å‚è€ƒç­”æ¡ˆï¼ˆå¡è¯ºå›¾ Karnaugh Mapï¼‰ï¼š**
> ```
> f0:     B                    f1:     B
>        A  0  1                      A  0  1
>     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
> C 0 â”‚ 0  â”‚ 0  â”‚ 1 â”‚ 0     C 0 â”‚ 1  â”‚ 0  â”‚ 1 â”‚ 0
>   1 â”‚ 1  â”‚ 0  â”‚ 0 â”‚ 0       1 â”‚ 1  â”‚ 0  â”‚ 1 â”‚ 0
>     â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
> ```

> âœ… **å®˜æ–¹è¡¨è¾¾å¼ï¼š**
> ```
> X = (not C and B and A) or (C and not B and not A) 
>     or (X and not B and not A) or (X and B and A)
> ```

---

## ç¬¬3é¢˜ - ç­‰ä»·é€»è¾‘å‡½æ•° (Equivalent Logic Functions) (4åˆ†)
**é¢˜ç›®ï¼š** å‹¾é€‰æ‰€æœ‰ä¸å…¶ä»–å‡½æ•°ç­‰ä»·çš„é€»è¾‘å‡½æ•°ã€‚
**[English]** Check all logic functions that have another equivalent function here.

```vhdl
y1 <= (A or D) and (not A or C);
y2 <= C or (A and C and B) or (not A and C and D);
y3 <= (not A and D) or (A and not D) or (C and D);
y4 <= (C and D) or (not A xor not D);
```

> âœ… **å®˜æ–¹å‚è€ƒç­”æ¡ˆï¼šy3 â‰¡ y4**

> ğŸ’¡ **è¯¦ç»†è§£æï¼š**
> ```
> y1 = (A + D)(Ä€ + C)
>    = AÄ€ + AC + DÄ€ + DC
>    = AC + Ä€D + CD
> ```
> 
> **y2ï¼š**
> ```
> y2 = C + ABC + Ä€CD
>    = C(1 + AB + Ä€D)
>    = C
> ```
> 
> **y3ï¼š**
> ```
> y3 = Ä€D + ADÌ„ + CD
>    = (A âŠ• D) + CD        â† å¼‚æˆ–å½¢å¼
> ```
> 
> **y4ï¼š**
> ```
> y4 = CD + (Ä€ âŠ• DÌ„)
>    = CD + (A âŠ• D)        âˆµ Ä€ âŠ• DÌ„ = A âŠ• D
>    = (A âŠ• D) + CD
> ```
> 
> **æ¯”è¾ƒç»“æœï¼š**
> - y1 = AC + Ä€D + CD
> - y2 = C
> - y3 = (A âŠ• D) + CD
> - y4 = (A âŠ• D) + CD
> 
> âœ… **ç­”æ¡ˆï¼šy3 â‰¡ y4**
> 
> ğŸ“Œ **å…³é”®å…¬å¼ï¼š** `Ä€ âŠ• BÌ„ = A âŠ• B`ï¼ˆå–ååçš„å¼‚æˆ–ç­‰äºåŸå¼‚æˆ–ï¼‰

---

## ç¬¬4é¢˜ - 8ä½å¯„å­˜å™¨è¿ç®— (2åˆ†)
**é¢˜ç›®ï¼š** å°†124+125+126+127è¿ç®—ç»“æœçš„ä½ä½å­˜å…¥1å­—èŠ‚å¯„å­˜å™¨ï¼Œä½œä¸º8ä½æ•°çš„åè¿›åˆ¶å€¼æ˜¯å¤šå°‘ï¼Ÿ
**[English]** If we store the lower bits of 124+125+126+127 operation into a 1-byte register, what decimal value will it hold as an 8-bit number?

**è®¡ç®—ï¼š**
```
124 + 125 + 126 + 127 = 502
502 mod 256 = 246
```

**ç­”æ¡ˆï¼š**
- a) unsigned: **246**
- b) signed: **-10** (246 - 256)

---

## ç¬¬5é¢˜ - Moore/Mealyè‡ªåŠ¨æœºå®šä¹‰ (3åˆ†)
**é¢˜ç›®ï¼š** è¡¥å…¨å®šä¹‰â€”â€”å¿…é¡»æ•°å­¦ä¸Šç²¾ç¡®ï¼
**[English]** Complete the definition - it must be mathematically precise!

**å®šä¹‰ï¼š** Automat Moore (Mealy) je uspoÅ™Ã¡danÃ¡ Å¡estice M = < X, S, Z, Ï‰, Î´, sâ‚€âˆˆS >

- **X** æ˜¯æœ‰é™è¾“å…¥å­—æ¯è¡¨ / is a finite input alphabet
- **S** æ˜¯æœ‰é™çŠ¶æ€é›†åˆ / is a finite set of states
- **Z** æ˜¯æœ‰é™è¾“å‡ºå­—æ¯è¡¨ / is a finite output alphabet
- **Î´** æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•° / is the state transition functionï¼šMoore: SÃ—Xâ†’Sï¼ŒMealy: SÃ—Xâ†’S
- **Ï‰** æ˜¯è¾“å‡ºå‡½æ•° / is the output functionï¼šMoore: Sâ†’Zï¼ŒMealy: SÃ—Xâ†’Z
- **sâ‚€** æ˜¯åˆå§‹çŠ¶æ€ / is the initial state

---

## ç¬¬6é¢˜ - +1åŠ æ³•å™¨è®¾è®¡ (7åˆ†)
**é¢˜ç›®ï¼š** +1åŠ æ³•å™¨å¯ä»¥ä¸ç”¨å…¨åŠ å™¨ï¼Œç”¨é—¨ç”µè·¯æ›´ç®€å•åœ°å®ç°ã€‚ç”»å‡ºç”±é—¨ç»„æˆçš„ç”µè·¯å›¾ã€‚
**[English]** The +1 adder can be implemented much simpler using gates without a full adder. Draw its schematic composed of gates.

**ç”µè·¯ç»“æ„ï¼š**
- s0 = x0 XOR 1 = NOT x0
- s1 = x1 XOR (x0)
- s2 = x2 XOR (x0 AND x1)
- s3 = x3 XOR (x0 AND x1 AND x2)
- carry = x0 AND x1 AND x2 AND x3

---

## ç¬¬7é¢˜ - VHDLä½æ“ä½œ (7åˆ†)
**é¢˜ç›®ï¼š** ç”¨å¹¶å‘ï¼ˆconcurrentï¼‰VHDLä»£ç æœ€ä¼˜åœ°æè¿°å›¾ä¸­ç”µè·¯ï¼Œä¸ä½¿ç”¨é¡ºåºè¯­å¥ã€‚æ•´ä¸ªæ¶æ„åªç”¨ä¸€æ¡è¯­å¥å¯å¾—æ»¡åˆ†ï¼Œæ¯å¤šä¸€æ¡æ‰£1åˆ†ã€‚
**[English]** Optimally describe the circuit in the figure using concurrent VHDL code without sequential statements. Full points for using only one statement in the architecture block; one point deducted for each additional statement.

```vhdl
library ieee; use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity Test20250609q7 is 
  port(x: in std_logic_vector(3 downto 0);
       y: out std_logic_vector(3 downto 0));
end entity;
architecture rtl of Test20250609q7 is
begin
  y <= x and (x(2 downto 0) & '1');
end architecture rtl;
```

---

## ç¬¬8é¢˜ - VHDLç”µè·¯åˆ†æ (7+1åˆ†)
**é¢˜ç›®ï¼š** æ ¹æ®ä»¥ä¸‹ä»£ç ï¼Œä½¿ç”¨é—¨ã€å¤šè·¯é€‰æ‹©å™¨ã€+1åŠ æ³•å™¨ã€æ¯”è¾ƒå™¨å’ŒDFFå¯„å­˜å™¨çš„ç¬¦å·ç”»å‡ºæ–¹æ¡†å›¾ã€‚
**[English]** Draw the block diagram for the circuit described by the following code, using symbols for gates, multiplexor, +1 adder, comparator, and DFF registers.

```vhdl
library ieee; use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity Ex20250609q7 is 
  port (CLK : in std_logic; Q : out std_logic);
end entity;
architecture rtl1 of Ex20250609q7 is
begin
  iproc: process(CLK)
    constant M: integer := 9;
    variable cntr : integer range 0 to M := 0;
    variable x : std_logic := '0';
  begin
    if rising_edge(CLK) then
      if cntr < M then 
        cntr := cntr + 1; 
      else 
        cntr := 0; 
        x := not x;
      end if;
    end if;
    Q <= x;
  end process;
end architecture;
```

**ç”µè·¯åç§°ï¼š** åˆ†é¢‘å™¨ï¼ˆFrequency Dividerï¼‰/ æ¨¡10è®¡æ•°å™¨å¸¦è¾“å‡ºç¿»è½¬

---

## ç¬¬9é¢˜ - åˆ†æ”¯é¢„æµ‹ (Branch Prediction) (8åˆ†)

> ğŸ›‘ **éè€ƒç‚¹æç¤º (Not on Exam):** æ ¹æ®2026å¹´1æœˆè€ƒè¯•è¯´æ˜ï¼Œåˆ†æ”¯é¢„æµ‹å™¨æœ¬æ¬¡ä¸è€ƒï¼Œå¯æˆ˜ç•¥æ€§è·³è¿‡ã€‚

**é¢˜ç›®ï¼š** Cç¨‹åºåœ¨æ•°ç»„ä¸­æŸ¥æ‰¾æœ€å°å€¼ã€‚å‡è®¾forå¾ªç¯ç¼–è¯‘ä¸ºdo-whileå½¢å¼ï¼Œå¤„ç†å™¨ä½¿ç”¨ä»¥ä¸‹é¢„æµ‹å™¨ï¼Œè®¡ç®—åˆ†æ”¯é¢„æµ‹é”™è¯¯æ¬¡æ•°ã€‚
**[English]** A C program finds the minimum in an array. Assuming the for-loop is compiled as do-while and the processor uses the following predictors, calculate the number of branch mispredictions.

```c
int data[] = { 0, 1, -2, -3, 4, -5, 6, -7, -8, 9 };
int min = INT_MAX;
for (int i = 0; i < 10; i++) {
  if (data[i] < min) min = data[i];
}
```

> âœ… **å®˜æ–¹å‚è€ƒç­”æ¡ˆ (Official Answer):**
> - 1ä½é¢„æµ‹å™¨ï¼ˆåˆå§‹NTï¼‰: misses = **9** (ifåˆ†æ”¯7æ¬¡ + forå¾ªç¯2æ¬¡)
> - 2ä½é¢„æµ‹å™¨ï¼ˆåˆå§‹WTï¼‰: misses = **7** (ifåˆ†æ”¯6æ¬¡ + forå¾ªç¯1æ¬¡)
> 
> ğŸ“ **å®˜æ–¹åˆ†æ”¯åºåˆ—åˆ†æï¼š**
> ```
> Branch: N  T  N  N  T  N  T  N  N  T
> Data:   0  1 -2 -3  4 -5  6 -7 -8  9
> ```
> 
> âš ï¸ **æ³¨æ„ï¼šä»Šå¹´è€ƒè¯•ä¸è€ƒåˆ†æ”¯é¢„æµ‹ï¼**ï¼ˆè€å¸ˆé‚®ä»¶ç¡®è®¤ï¼‰
> ğŸ“Œ **æ³¨æ„ï¼š** å®é™…ç­”æ¡ˆå¯èƒ½å› ç¼–è¯‘å™¨ä¼˜åŒ–å’Œåˆ†æ”¯é¢„æµ‹å™¨å…·ä½“å®ç°è€Œç•¥æœ‰ä¸åŒ
