# LSP Exam 2022-01-24 / ZkouÅ¡ka LSP 2022-01-24 / LSPè€ƒè¯• 2022å¹´1æœˆ24æ—¥

> **Course**: B0B35LSP - LogickÃ© systÃ©my a procesory | BE5B35LSP - Logic Systems and Processors
> **University**: CVUT FEL (ÄŒVUT) - ÄŒeskÃ© vysokÃ© uÄenÃ­ technickÃ© v Praze | Czech Technical University in Prague
> **Keywords**: LSP, Exam, ZkouÅ¡ka, 2022-01-24, Shannon expansion, RS latch, VHDL
>
> [ğŸ‡¨ğŸ‡³ CN Version](./2022-01-24_Exam_CN.md) | [ğŸ‡¬ğŸ‡§ EN Version](./2022-01-24_Exam_EN.md) | [ğŸ‡¨ğŸ‡¿ CZ Version](./2022-01-24_Exam_CZ.md)

---

# LSPè€ƒè¯• 2022å¹´1æœˆ24æ—¥ï¼ˆè‹±æ–‡ç‰ˆï¼‰
> ğŸ§  **AIæ¨æ¼”ç‰ˆæœ¬** - æœ¬è¯•å·PDFæ— å®˜æ–¹ç­”æ¡ˆï¼Œä»¥ä¸‹ä¸ºæ¨æ¼”è§£æ

## è€ƒè¯•ä¿¡æ¯
- æ—¥æœŸï¼š2022å¹´1æœˆ24æ—¥
- è¯­è¨€ï¼šæ·å…‹è¯­/è‹±è¯­åŒè¯­
- æ€»åˆ†ï¼š50åˆ†ï¼ˆç¬¬ä¸€éƒ¨åˆ†25åˆ†>8 + ç¬¬äºŒéƒ¨åˆ†25åˆ†>8ï¼‰

---

## ç¬¬1é¢˜ - Shannonå±•å¼€ (6åˆ†)
**é¢˜ç›®ï¼š** å°†ç”µè·¯çš„X,Y=f(A,B,C)å‡½æ•°ç”¨Shannonå±•å¼€åˆ†è§£ä¸ºï¼š
**[English]** Decompose the circuit functions X,Y=f(A,B,C) using Shannon expansion into:
$$X,Y = (\overline{C} \land f_0(A,B)) \lor (C \land f_1(A,B))$$

å°†fâ‚€å’Œfâ‚å†™æˆå¡è¯ºå›¾

**åˆ†åˆ«ä¸ºXå’ŒYå„ç”»ä¸¤ä¸ªå¡è¯ºå›¾ï¼š**
```
Xçš„f0=      A        Xçš„f1=      A
       0  1               0  1
    â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€     â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€
B 0 â”‚     â”‚         B 0 â”‚     â”‚
  1 â”‚     â”‚           1 â”‚     â”‚

Yçš„f0=      A        Yçš„f1=      A
       0  1               0  1
    â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€     â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€
B 0 â”‚     â”‚         B 0 â”‚     â”‚
  1 â”‚     â”‚           1 â”‚     â”‚
```

---

## ç¬¬2é¢˜ - æœ‰ç¬¦å·/æ— ç¬¦å·è¿ç®— (4åˆ†)
**é¢˜ç›®ï¼š** åœ¨8ä½åŠ æ³•å™¨ä¸Šæ‰§è¡Œ96+97+98+99ï¼Œç»“æœä½œä¸º8ä½æ•°çš„åè¿›åˆ¶å€¼æ˜¯å¤šå°‘ï¼Ÿ
**[English]** Perform 96+97+98+99 on an 8-bit adder, what is the decimal value of the result as an 8-bit number?

**è®¡ç®—ï¼š**
- 96+97+98+99 = 390
- 390 mod 256 = 134

**ç­”æ¡ˆï¼š**
- a) **unsignedï¼ˆæ— ç¬¦å·ï¼‰**: 134
- b) **signedï¼ˆäºŒè¿›åˆ¶è¡¥ç æœ‰ç¬¦å·ï¼‰**: 134-256 = **-122**

---

## ç¬¬3é¢˜ - 1:4è§£å¤ç”¨å™¨è®¾è®¡ (10åˆ†)
**é¢˜ç›®ï¼š** ç”»å‡º1:4è§£å¤ç”¨å™¨çš„é€»è¾‘ç”µè·¯å›¾
**[English]** Draw the logic circuit diagram of a 1:4 demultiplexer

**ç¬¦å·ï¼š**
```
         y1 y0
Data â”€â”€â”¤ 0 â”œâ”€â”€ x0
       â”‚ 1 â”œâ”€â”€ x1
       â”‚ 2 â”œâ”€â”€ x2
       â”‚ 3 â”œâ”€â”€ x3
```

**é€»è¾‘æ–¹ç¨‹ï¼š**
```
x0 = Data and (not y1) and (not y0)
x1 = Data and (not y1) and y0
x2 = Data and y1 and (not y0)
x3 = Data and y1 and y0
```

---

## ç¬¬4é¢˜ - RSé”å­˜å™¨ä»¿çœŸ (5åˆ†)
**é¢˜ç›®ï¼š** ç»™å®šè¾“å…¥A, B, Cåœ¨æ—¶é—´t0-t4çš„å€¼ï¼Œå†™å‡ºXå’ŒYè¾“å‡ºçš„å€¼
**[English]** Given inputs A, B, C values at times t0-t4, write the values of X and Y outputs

**è¾“å…¥åºåˆ—ï¼š**
```
A = 1 | 0 | 1 | 0 | 1
B = 0 | 0 | 1 | 0 | 0
C = 0 | 1 | 0 | 0 | 0
    t0  t1  t2  t3  t4
```

---

## ç¬¬5é¢˜ - VHDLä»£ç RTLåˆ†æ (10åˆ†)
**é¢˜ç›®ï¼š** ç”»å‡ºä»¥ä¸‹VHDLä»£ç çš„RTLè§†å›¾ï¼Œå¹¶æ­£ç¡®å‘½åè¯¥ç”µè·¯
**[English]** Draw the RTL view of the following VHDL code and correctly name the circuit

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity XXX is port(a, b : in std_logic; c : out std_logic); end entity;
architecture beh of XXX is 
begin 
  process (a,b) 
    variable d:std_logic:='0'; 
    variable e:integer range 0 to 25:=0;
  begin 
    if b='0' then 
      e:=0; d:='0'; 
    elsif rising_edge(a) then 
      if e<25 then 
        e:=e+1; 
      else 
        e:=0; d:=not d; 
      end if;
    end if; 
    c<=d; 
  end process; 
end architecture;
```

**åŠŸèƒ½åˆ†æï¼š**
- b='0'æ˜¯å¼‚æ­¥å¤ä½
- açš„ä¸Šå‡æ²¿è§¦å‘
- è®¡æ•°åˆ°25åè¾“å‡ºç¿»è½¬
- **åç§°ï¼š26åˆ†é¢‘å™¨** (Frequency Divider by 26)

**RTLè§†å›¾åŒ…å«ï¼š**
- 5ä½è®¡æ•°å™¨ï¼ˆ0-25ï¼‰
- æ¯”è¾ƒå™¨ï¼ˆe < 25, e = 25ï¼‰
- Dè§¦å‘å™¨ï¼ˆå­˜å‚¨dï¼‰
- å¼‚æ­¥å¤ä½é€»è¾‘

---

## ç¬¬6é¢˜ - è§£å¤ç”¨å™¨VHDLæè¿° (5åˆ†)
**é¢˜ç›®ï¼š** ç”¨æœ€ç®€å•çš„æ–¹å¼æè¿°ç¬¬3é¢˜çš„è§£å¤ç”¨å™¨
**[English]** Describe the demultiplexer from question 3 in the simplest way

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity yyy is 
  port(Data: in std_logic; 
       y: in std_logic_vector(1 downto 0); 
       x: out std_logic_vector(3 downto 0)); 
end entity;
architecture dataflow of yyy is
begin
  x <= (others => '0');
  x(to_integer(unsigned(y))) <= Data;
end architecture;
```

---

## ç¬¬7é¢˜ - 16åˆ†é¢‘å™¨è®¾è®¡ (5åˆ†)
**é¢˜ç›®ï¼š** åœ¨æœªå®Œæˆçš„ç”µè·¯ä¸­æ·»åŠ æœ€å°‘å…ƒä»¶ï¼Œåˆ›å»ºCLKçš„åŒæ­¥16åˆ†é¢‘å™¨ï¼ˆä½¿ç”¨+1åŠ æ³•å™¨ï¼‰
**[English]** Add minimum components to the incomplete circuit to create a synchronous divide-by-16 of CLK (using +1 adder)

**è®¾è®¡æ€è·¯ï¼š**
```
CLK â”€â”€â”¬â”€â”€> +1åŠ æ³•å™¨ â”€â”€> 4ä¸ªDFF â”€â”€> DIV16
      â”‚                    â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- 4ä½è®¡æ•°å™¨ï¼ˆ0-15å¾ªç¯ï¼‰
- DIV16 = Q3ï¼ˆæœ€é«˜ä½ï¼‰
- æ¯16ä¸ªæ—¶é’Ÿå‘¨æœŸå®Œæˆä¸€æ¬¡

---

## ç¬¬8é¢˜ - ç”µæœºæ§åˆ¶ç”µè·¯ (5åˆ†)
**é¢˜ç›®ï¼š** è®¾è®¡ç”µè·¯ï¼šæŒ‰ä¸€æ¬¡åŒææŒ‰é’®å¼€å¯ç”µæœºï¼Œå†æŒ‰å…³é—­ã€‚ä¸Šç”µåç”µæœºå¿…é¡»å…³é—­ã€‚
**[English]** Design a circuit: press a double-pole button once to start motor, press again to stop. Motor must be off after power-up.

**å…³é”®ç»„ä»¶ï¼š**
- DFFè§¦å‘å™¨
- å¼‚æ­¥æ¸…é›¶ï¼ˆä¸Šç”µå¤ä½ï¼‰
- ç»§ç”µå™¨é©±åŠ¨
- é˜²æŠ–åŠ¨ç”µè·¯

---

## ç¬¬9é¢˜ - é™„åŠ é¢˜ï¼šè¾¹æ²¿æ£€æµ‹å™¨ (10åˆ†)
**é¢˜ç›®ï¼š** å½“Dè¾“å…¥æ”¹å˜å€¼æ—¶ï¼ŒYè¾“å‡ºä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸçš„'1'ã€‚RESETæ˜¯åŒæ­¥å¤ä½ã€‚
**[English]** When D input changes value, Y outputs '1' for one clock cycle. RESET is synchronous reset.

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity Edges is 
  port (clk, Reset, D : in std_logic; Y: out std_logic);
end entity;
architecture rtl of Edges is
  signal D_prev : std_logic := '0';
begin
  process(clk)
  begin
    if rising_edge(clk) then
      if Reset = '1' then
        D_prev <= '0';
        Y <= '0';
      else
        if D /= D_prev then
          Y <= '1';
        else
          Y <= '0';
        end if;
        D_prev <= D;
      end if;
    end if;
  end process;
end architecture;
```

---

## çŸ¥è¯†ç‚¹æ€»ç»“

### æœ¬æ¬¡è€ƒè¯•é‡ç‚¹
1. Shannonå±•å¼€ï¼ˆåŒè¾“å‡ºï¼‰
2. **8ä½æœ‰ç¬¦å·/æ— ç¬¦å·è¿ç®—**ï¼ˆé‡è¦ï¼š390 mod 256ï¼‰
3. **1:4è§£å¤ç”¨å™¨è®¾è®¡**
4. RSé”å­˜å™¨ä»¿çœŸ
5. **VHDLä»£ç RTLåˆ†æ**ï¼ˆåˆ†é¢‘å™¨è¯†åˆ«ï¼‰
6. è§£å¤ç”¨å™¨VHDLæè¿°
7. 16åˆ†é¢‘å™¨è®¾è®¡
8. ç”µæœºæ§åˆ¶ç”µè·¯
9. è¾¹æ²¿æ£€æµ‹å™¨è®¾è®¡

### é‡è¦å…¬å¼
- 8ä½æ— ç¬¦å·èŒƒå›´ï¼š0-255
- 8ä½æœ‰ç¬¦å·èŒƒå›´ï¼š-128 to 127
- æº¢å‡ºå¤„ç†ï¼šresult mod 2^n
