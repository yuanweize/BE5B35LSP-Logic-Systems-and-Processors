````markdown
# LSP ZkouÅ¡ka - 21. ledna 2015

> **CVUT FEL (ÄŒVUT) - ÄŒeskÃ© vysokÃ© uÄenÃ­ technickÃ© v Praze | Czech Technical University in Prague**
>
> ğŸ‡¨ğŸ‡³ [ä¸­æ–‡ç‰ˆ](2015-01-21_Exam_CN.md) | ğŸ‡¬ğŸ‡§ [English](2015-01-21_Exam_EN.md) | ğŸ‡¨ğŸ‡¿ [ÄŒeÅ¡tina](2015-01-21_Exam_CZ.md)

> ğŸ§  **AI-generovanÃ© Å™eÅ¡enÃ­** - ReferenÄnÃ­ analÃ½za nÃ­Å¾e

---

## Ãšloha 2: Simulace obvodu RS klopnÃ©ho obvodu â­ÄŒasto testovÃ¡no

**ZadÃ¡nÃ­**: PÅ™i hodnotÃ¡ch vstupÅ¯ A, B, C v Äasech t0, t1, t2, t3 zobrazenÃ½ch nÃ­Å¾e napiÅ¡te hodnotu vÃ½stupu Q.

```
A = ..0..|..1..|..1..|..1..|
B = ..0..|..0..|..0..|..1..|
C = ..1..|..1..|..0..|..0..|

t0   t1   t2   t3
```

### OdpovÄ›Ä
```
Q = ...1...|â€¦0â€¦.|â€¦0â€¦.|â€¦1.â€¦|
```

---

## Ãšloha 3: ShannonÅ¯v rozklad â­ÄŒasto testovÃ¡no

**ZadÃ¡nÃ­**: RozloÅ¾te funkci `Q=f(A,B,C,Q)` z Ãºlohy 2 do tvaru:

```
Q = (not Q and f0(A,B,C)) or (Q and f1(A,B,C))
```

### Postup Å™eÅ¡enÃ­

```
f0 := f(A,B,C,'0') := (A â‰¡ B) Â· ('0' + (B â‰  C)) := (A â‰¡ B) Â· (B â‰  C)
f1 := f(A,B,C,'1') := (A â‰¡ B) Â· ('1' + (B â‰  C)) := (A â‰¡ B) Â· '1' := (A â‰¡ B)
```

### f0 Karnaughova mapa (A â‰¡ B) Â· (B â‰  C)

|f0 | C=0 | C=1 |
|---|-----|-----|
|AB=00| 0 | 1 |
|AB=01| 0 | 0 |
|AB=11| 1 | 0 |
|AB=10| 0 | 0 |

### f1 Karnaughova mapa (A â‰¡ B)

|f1 | C=0 | C=1 |
|---|-----|-----|
|AB=00| 1 | 1 |
|AB=01| 0 | 0 |
|AB=11| 1 | 1 |
|AB=10| 0 | 0 |

---

## Ãšloha 4: ZnamÃ©nkovÃ©/NeznamÃ©nkovÃ© bitovÃ© hodnoty â­ÄŒasto testovÃ¡no

**ZadÃ¡nÃ­**: JakÃ¡ je desetinnÃ¡ hodnota 10bitovÃ©ho binÃ¡rnÃ­ho ÄÃ­sla `10 0000 1111`?

a) **NeznamÃ©nkovÃ© (unsigned)**: ____________________

b) **DvojkovÃ½ doplnÄ›k (signed)**: ____________________

### OdpovÄ›Ä

```
10 0000 1111 (binÃ¡rnÄ›)

a) NeznamÃ©nkovÃ©: 2^9 + 2^3 + 2^2 + 2^1 + 2^0 = 512 + 8 + 4 + 2 + 1 = 527

b) DvojkovÃ½ doplnÄ›k (znamÃ©nkovÃ©): 
   MSB je 1, coÅ¾ oznaÄuje zÃ¡pornÃ© ÄÃ­slo
   = -2^9 + (0 0000 1111)
   = -512 + 15 = -497
```

---

## Ãšloha 5: EkvivalentnÃ­ logickÃ© funkce â­ÄŒasto testovÃ¡no

**ZadÃ¡nÃ­**: OznaÄte vÅ¡echny logickÃ© funkce, kterÃ© jsou ekvivalentnÃ­ s jinÃ½mi funkcemi:

```vhdl
f1 <= (A xor C) or (A and not C);
f2 <= (B or C) and (not A or B or C);
f3 <= ((C and not B) or (B and A));
f4 <= (A or C) and (not A or not C);
f5 <= (A and not B) xor (A and C);
f6 <= (A and not C) or (C and not A);
```

### Postup Å™eÅ¡enÃ­
Nakreslete Karnaughovy mapy pro kaÅ¾dou funkci a porovnejte je pro nalezenÃ­ ekvivalentnÃ­ch!

**NÃ¡povÄ›da**: f4 a f6 jsou obÄ› ekvivalentnÃ­ A XOR C

---

## Ãšloha 6: KreslenÃ­ RS klopnÃ©ho obvodu â­ÄŒasto testovÃ¡no

**ZadÃ¡nÃ­**: Nakreslete RS klopnÃ½ obvod pouze pomocÃ­ hradel NOR a nakreslete RS klopnÃ½ obvod pouze pomocÃ­ hradel NAND.

### RS klopnÃ½ obvod s hradly NOR
```
S â”€â”€â”¬â”€â”€[NOR]â”€â”€â”¬â”€â”€ Q
    â”‚    â”‚    â”‚
    â””â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”˜
         â”‚
R â”€â”€â”¬â”€â”€[NOR]â”€â”€â”¬â”€â”€ QÌ„
    â”‚    â”‚    â”‚
    â””â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”˜
```

### RS klopnÃ½ obvod s hradly NAND
```
SÌ„ â”€â”€â”¬â”€â”€[NAND]â”€â”€â”¬â”€â”€ Q
    â”‚     â”‚    â”‚
    â””â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”˜
          â”‚
RÌ„ â”€â”€â”¬â”€â”€[NAND]â”€â”€â”¬â”€â”€ QÌ„
    â”‚     â”‚    â”‚
    â””â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”˜
```

**PoznÃ¡mka**: Vstupy RS klopnÃ©ho obvodu typu NAND jsou aktivnÃ­ v nÃ­zkÃ© Ãºrovni!

---

## Ãšloha 7: NÃ¡vrh asynchronnÃ­ dÄ›liÄky

**ZadÃ¡nÃ­**: PÅ™idejte hradla a propojenÃ­ do neÃºplnÃ©ho diagramu pro vytvoÅ™enÃ­ asynchronnÃ­ dÄ›liÄky hodinovÃ©ho signÃ¡lu CLK dÄ›lenÃ­m 18 s asynchronnÃ­m resetem ACLRN.

Pro implementaci pouÅ¾ijte 5 DFF klopnÃ½ch obvodÅ¯.

### NÃ¡vrhovÃ½ pÅ™Ã­stup
- 18 = 2 Ã— 9 = 2 Ã— 3 Ã— 3
- Je tÅ™eba detekovat hodnotu ÄÃ­taÄe 17 (10001) a resetovat

---

## Ãšloha 8: AnalÃ½za VHDL kÃ³du

**ZadÃ¡nÃ­**: Analyzujte nÃ¡sledujÃ­cÃ­ Å¡patnÄ› naformÃ¡tovanÃ½ VHDL kÃ³d, nakreslete odpovÃ­dajÃ­cÃ­ schÃ©ma logickÃ©ho obvodu a uveÄte nÃ¡zev popisujÃ­cÃ­ jeho funkci.

```vhdl
library IEEE; use IEEE.STD_LOGIC_1164.all;
entity test20140214 is port (a, b, c, d : in std_logic; e : out std_logic); end;
architecture rtl of test20140214 is begin
process(a, b) variable z:std_logic_vector(0 to 3); begin
if b = '0' then z:=(others=>'0'); 
elsif rising_edge(a) then
  if c='1' then z:=d & z(0 to 2); 
  else z:=z(3) & z(0 to 2); 
  end if; 
end if; 
e<=z(3); 
end process; 
end rtl;
```

### AnalÃ½za kÃ³du
- **Funkce**: 4bitovÃ½ posuvnÃ½ registr
- **Vstupy**: a (hodiny), b (asynchronnÃ­ nulovÃ¡nÃ­), c (vÃ½bÄ›r reÅ¾imu), d (datovÃ½ vstup)
- **VÃ½stup**: e = z(3)
- KdyÅ¾ c='1': SÃ©riovÃ½ vstup d, posun vpravo
- KdyÅ¾ c='0': KruhovÃ½ posun vpravo

---

## ShrnutÃ­ znalostÃ­

| Typ Ãºlohy | Koncept | SEL Reference |
|-----------|---------|---------------|
| ShannonÅ¯v rozklad | Dekompozice funkce | s.11-14 |
| ZnamÃ©nkovÃ©/NeznamÃ©nkovÃ© | VÃ½poÄet bitovÃ© hodnoty | s.2-3 |
| EkvivalentnÃ­ funkce | PorovnÃ¡nÃ­ KarnaughovÃ½ch map | s.4-7 |
| RS klopnÃ½ obvod | Implementace NOR/NAND | s.11-14 |
| DÄ›liÄka | NÃ¡vrh digitÃ¡lnÃ­ho ÄÃ­taÄe | - |
| AnalÃ½za VHDL | PorozumÄ›nÃ­ kÃ³du | - |

````
