# ZkouÅ¡ka LSP 2023-06-23

> **Course**: B0B35LSP - LogickÃ© systÃ©my a procesory | BE5B35LSP - Logic Systems and Processors
> **University**: CVUT FEL (ÄŒVUT) - ÄŒeskÃ© vysokÃ© uÄenÃ­ technickÃ© v Praze | Czech Technical University in Prague
> **Keywords**: LSP, Exam, ZkouÅ¡ka, 2023-06-23, Shannon expansion, branch predictor, cache, VHDL
>
> [ğŸ‡¨ğŸ‡³ CN Version](./2023-06-23_Exam_CN.md) | [ğŸ‡¬ğŸ‡§ EN Version](./2023-06-23_Exam_EN.md) | [ğŸ‡¨ğŸ‡¿ CZ Version](./2023-06-23_Exam_CZ.md)

---

# ZkouÅ¡ka LSP 2023-06-23
> ğŸ§  **AI odvozenÃ¡ verze** â€“ V PDF nejsou oficiÃ¡lnÃ­ odpovÄ›di; nÃ­Å¾e jsou odvozenÃ© poznÃ¡mky/Å™eÅ¡enÃ­.

## Informace o zkouÅ¡ce
- Datum: 2023-06-23
- Jazyk: ÄeÅ¡tina
- Obsahuje statistickÃ© grafy

---

## Ãšloha 1 â€“ Simulace RS zÃ¡chytu (4 b)
**ZadÃ¡nÃ­:** Pro danÃ© hodnoty vstupÅ¯ A, B, C v Äasech t0â€“t4 urÄete vÃ½stupy X a Y.

**VstupnÃ­ posloupnost:**
```
A = 1 | 1 | 0 | 0 | 0
B = 0 | 1 | 1 | 1 | 0
C = 0 | 0 | 0 | 1 | 1
    t0  t1  t2  t3  t4
```

> ğŸ§  **AI odvozenÃ¡ odpovÄ›Ä:**
> - **t0**: A=1 â†’ Reset, X=0, Y=1
> - **t1**: A=1, BÂ·C=0 â†’ Reset drÅ¾Ã­, X=0, Y=1
> - **t2**: A=0, BÂ·C=0 â†’ drÅ¾enÃ­
> - **t3**: A=0, BÂ·C=1 â†’ Set, X=1, Y=0
> - **t4**: A=0, BÂ·C=0 â†’ drÅ¾enÃ­
> - HypotÃ©za: **X=00011**, **Y=11100** (ovÄ›Å™te dle skuteÄnÃ©ho schÃ©matu)

---

## Ãšloha 2 â€“ ShannonÅ¯v rozklad (6 b)
**ZadÃ¡nÃ­:** RozloÅ¾te $X=f(A,B,C,X)$ do tvaru:
$$X = (\overline{X} \land f_0(A,B,C)) \lor (X \land f_1(A,B,C))$$

---

## Ãšloha 3 â€“ EkvivalentnÃ­ logickÃ© funkce (4 b)
**ZadÃ¡nÃ­:** ZaÅ¡krtnÄ›te vÅ¡echny logickÃ© funkce, kterÃ© jsou ekvivalentnÃ­:

```vhdl
y1 <= B or (not A and B and D) or (A and B and C);
y2 <= (B and D) or (D and not A) or (A and not D);
y3 <= (A or D) and (B or D or not A);
y4 <= (not A xor not D) or (B and D);
```

---

## Ãšloha 4 â€“ VHDL funkce (prÅ¯mÄ›r AS7) (6 b)
**ZadÃ¡nÃ­:** NapiÅ¡te VHDL funkci pro vÃ½poÄet zaokrouhlenÃ©ho celoÄÃ­selnÃ©ho prÅ¯mÄ›ru pole typu `AS7`. PoÅ¾adavek: co nejrychlejÅ¡Ã­ hardwarovÃ¡ realizace.

```vhdl
type AS7 is array(0 to 6) of integer range -2**15 to 2**15-1;

function meanAS7(x: AS7) return integer is
  variable sum : integer;
begin
  sum := x(0) + x(1) + x(2) + x(3) + x(4) + x(5) + x(6);
  return (sum + 3) / 7;  -- +3 pro zaokrouhlenÃ­
end function;
```

**Tipy na optimalizaci:**
- paralelnÃ­ sÄÃ­tÃ¡nÃ­ (adder tree)
- vyhnout se dÄ›lenÃ­ (nahradit nÃ¡sobenÃ­m/posuvem)
- 7 â‰ˆ $2^3 - 1$ lze vyuÅ¾Ã­t

---

## Ãšloha 5 â€“ Realizace multiplexoru (8 b)
**ZadÃ¡nÃ­:** Realizujte danÃ½ multiplexor pouze pomocÃ­ hradel AND, NAND, OR, NOR a invertorÅ¯.

**Symbolicky:**
```
     x â”€â”€â”€ 0 â”€â”¬â”€ 0 â”€â”
     y â”€â”€â”€ 1 â”€â”¤     â”œâ”€ q
     z â”€â”€â”€â”€â”€â”€â”€â”´â”€ 1 â”€â”˜
     a0
     a1
```

**Rovnice:**
```
q = (not a1 and not a0 and x) or 
    (not a1 and a0 and y) or 
    (a1 and z)
```

ZjednoduÅ¡enÃ­:
```
q = (not a1 and ((not a0 and x) or (a0 and y))) or (a1 and z)
```

---

## Ãšloha 6 â€“ VHDL popis multiplexoru (6 b)
**ZadÃ¡nÃ­:** PopiÅ¡te obvod z Ãšlohy 5 co nejjednoduÅ¡eji ve VHDL.

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity yyy is 
  port(x, y, z, a1, a0: in std_logic; 
       q: out std_logic);
end entity;
architecture dataflow of yyy is
begin
  q <= z when a1='1' else
       y when a0='1' else
       x;
end architecture;
```

---

## Ãšloha 7 â€“ Prediktor skokÅ¯ (6 b)
> ğŸ›‘ **PoznÃ¡mka (nenÃ­ zkouÅ¡eno):** Podle poznÃ¡mek k roku 2026 se vÃ½poÄty prediktoru skokÅ¯ netestujÃ­; lze pÅ™eskoÄit.

**ZadÃ¡nÃ­:** Program v C hledÃ¡ minimum v poli. PÅ™edpoklÃ¡dejte, Å¾e `for` je pÅ™eloÅ¾en jako `do-while`. SpoÄÃ­tejte poÄet chybnÃ½ch predikcÃ­.

```c
int data[] = { 0, 1, 2, 3, 4, -5, -6, -7, 8, 9 };
int min = INT_MAX;
for (int i = 0; i < sizeof(data)/sizeof(int); i++)
{ 
  if (data[i] < min) min = data[i];
}
```

**MÃ­sta pro odpovÄ›Ä:**
- 1bitovÃ½ prediktor (poÄÃ¡teÄnÄ› Not-Taken): misses = ?
- 2bitovÃ½ prediktor (poÄÃ¡teÄnÄ› Weakly Taken): misses = ?

---

## Ãšloha 8 â€“ VÃ½poÄet cache (10 b)
> ğŸ›‘ **PoznÃ¡mka (nenÃ­ zkouÅ¡eno):** Podle poznÃ¡mek k roku 2026 se vÃ½poÄty cache missÅ¯ netestujÃ­; lze pÅ™eskoÄit.

**ZadÃ¡nÃ­:** 32bit procesor, cache 128 B, 2-way set associative, dÃ©lka Å™Ã¡dku 1 slovo, LRU.
Sekvence pÅ™Ã­stupÅ¯: `0x14, 0x94, 0x14, 0x94, 0x114, 0x14`

**Parametry cache:**
- Slovo = 4 bajty
- Å˜Ã¡dek 1 slovo = 4 bajty
- 128 B / 4 B = 32 Å™Ã¡dkÅ¯
- 2-way: 32 / 2 = 16 sad
- Rozklad adresy:
  - Offset: 2 bity
  - Index sady: 4 bity
  - Tag: zbytek

---

## Ãšloha 9 â€“ Bonus: 3bitovÃ½ JohnsonÅ¯v ÄÃ­taÄ (10 b)
**ZadÃ¡nÃ­:** Implementujte 3bitovÃ½ synchronnÃ­ JohnsonÅ¯v ÄÃ­taÄ.
- RESET='1' â†’ Q="000"
- DN=0 dopÅ™edu: 000,001,011,111,110,100,000...
- DN=1 dozadu

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity JC3 is 
  port (clk, DN, RESET: in std_logic;
        Q: out std_logic_vector(2 downto 0));
end entity;
architecture rtl of JC3 is
  signal q_int : std_logic_vector(2 downto 0) := "000";
begin
  process(clk)
  begin
    if rising_edge(clk) then
      if RESET = '1' then
        q_int <= "000";
      elsif DN = '0' then
        q_int <= q_int(1 downto 0) & (not q_int(2));
      else
        q_int <= (not q_int(0)) & q_int(2 downto 1);
      end if;
    end if;
  end process;
  Q <= q_int;
end architecture;
```

---

## ShrnutÃ­ tÃ©mat

### HlavnÃ­ okruhy
1. Simulace RS zÃ¡chytu
2. ShannonÅ¯v rozklad
3. EkvivalentnÃ­ logickÃ© funkce
4. **VHDL funkce** (rychlÃ½ prÅ¯mÄ›r)
5. Realizace multiplexoru
6. VHDL popis multiplexoru
7. **Prediktor skokÅ¯**
8. **VÃ½poÄet cache** (2-way)
9. JohnsonÅ¯v ÄÃ­taÄ
