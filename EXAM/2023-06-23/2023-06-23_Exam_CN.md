# LSP Exam 2023-06-23 / ZkouÅ¡ka LSP 2023-06-23 / LSPè€ƒè¯• 2023å¹´6æœˆ23æ—¥

> **Course**: B0B35LSP - LogickÃ© systÃ©my a procesory | BE5B35LSP - Logic Systems and Processors
> **University**: CVUT FEL (ÄŒVUT) - ÄŒeskÃ© vysokÃ© uÄenÃ­ technickÃ© v Praze | Czech Technical University in Prague
> **Keywords**: LSP, Exam, ZkouÅ¡ka, 2023-06-23, Shannon expansion, branch predictor, cache, VHDL
>
> [ğŸ‡¨ğŸ‡³ CN Version](./2023-06-23_Exam_CN.md) | [ğŸ‡¬ğŸ‡§ EN Version](./2023-06-23_Exam_EN.md) | [ğŸ‡¨ğŸ‡¿ CZ Version](./2023-06-23_Exam_CZ.md)

---

# LSPè€ƒè¯• 2023å¹´6æœˆ23æ—¥
> ğŸ§  **AIæ¨æ¼”ç‰ˆæœ¬** - æœ¬è¯•å·PDFæ— å®˜æ–¹ç­”æ¡ˆï¼Œä»¥ä¸‹ä¸ºæ¨æ¼”è§£æ

## è€ƒè¯•ä¿¡æ¯
- æ—¥æœŸï¼š2023å¹´6æœˆ23æ—¥
- è¯­è¨€ï¼šæ·å…‹è¯­
- åŒ…å«ç»Ÿè®¡æ•°æ®å›¾è¡¨

---

## ç¬¬1é¢˜ - RSé”å­˜å™¨ä»¿çœŸ (4åˆ†)
**é¢˜ç›®ï¼š** ç»™å®šè¾“å…¥A, B, Cåœ¨æ—¶é—´t0-t4çš„å€¼ï¼Œå†™å‡ºXå’ŒYè¾“å‡ºçš„å€¼
**[English]** Given inputs A, B, C values at times t0-t4, write the values of X and Y outputs

**è¾“å…¥åºåˆ—ï¼š**
```
A = 1 | 1 | 0 | 0 | 0
B = 0 | 1 | 1 | 1 | 0
C = 0 | 0 | 0 | 1 | 1
    t0  t1  t2  t3  t4
```

> ğŸ§  **AIæ¨æ¼”ç­”æ¡ˆ (AI Generated):**
> - **t0**: A=1 â†’ Reset, X=0, Y=1
> - **t1**: A=1, BÂ·C=0 â†’ Resetä¿æŒ, X=0, Y=1
> - **t2**: A=0, BÂ·C=0 â†’ ä¿æŒ
> - **t3**: A=0, BÂ·C=1 â†’ Set, X=1, Y=0
> - **t4**: A=0, BÂ·C=0 â†’ ä¿æŒ
> - æ¨æµ‹ï¼š**X=00011**, **Y=11100** (éœ€æ ¹æ®å®é™…ç”µè·¯éªŒè¯)

---

## ç¬¬2é¢˜ - Shannonå±•å¼€ (6åˆ†)
**é¢˜ç›®ï¼š** å°†X=f(A,B,C,X)åˆ†è§£ä¸ºï¼š
**[English]** Decompose X=f(A,B,C,X) into:
$$X = (\overline{X} \land f_0(A,B,C)) \lor (X \land f_1(A,B,C))$$

---

## ç¬¬3é¢˜ - ç­‰ä»·é€»è¾‘å‡½æ•° (4åˆ†)
**é¢˜ç›®ï¼š** å‹¾é€‰æ‰€æœ‰å…·æœ‰ç­‰ä»·å‡½æ•°çš„é€»è¾‘å‡½æ•°ï¼š
**[English]** Check all logic functions that have an equivalent function:

```vhdl
y1 <= B or (not A and B and D) or (A and B and C);
y2 <= (B and D) or (D and not A) or (A and not D);
y3 <= (A or D) and (B or D or not A);
y4 <= (not A xor not D) or (B and D);
```

---

## ç¬¬4é¢˜ - VHDLå‡½æ•°ç¼–å†™ (6åˆ†)
**é¢˜ç›®ï¼š** ç¼–å†™VHDLå‡½æ•°ï¼Œè®¡ç®—AS7ç±»å‹æ•°ç»„çš„å››èˆäº”å…¥æ•´æ•°å¹³å‡å€¼ã€‚è¦æ±‚æœ€å¿«çš„ç¡¬ä»¶è®¡ç®—é€Ÿåº¦ã€‚
**[English]** Write a VHDL function to calculate the rounded integer average of an AS7 type array. Require fastest hardware calculation speed.

```vhdl
type AS7 is array(0 to 6) of integer range -2**15 to 2**15-1;

function meanAS7(x: AS7) return integer is
  variable sum : integer;
begin
  sum := x(0) + x(1) + x(2) + x(3) + x(4) + x(5) + x(6);
  return (sum + 3) / 7;  -- +3å®ç°å››èˆäº”å…¥
end function;
```

**ä¼˜åŒ–æŠ€å·§ï¼š**
- å¹¶è¡ŒåŠ æ³•ï¼ˆæ ‘å½¢ç»“æ„ï¼‰
- é¿å…é™¤æ³•ï¼ˆä½¿ç”¨ä¹˜æ³•å’Œç§»ä½è¿‘ä¼¼ï¼‰
- 7 â‰ˆ 2Â³ - 1ï¼Œå¯ç”¨ç‰¹æ®ŠæŠ€å·§

---

## ç¬¬5é¢˜ - å¤šè·¯å¤ç”¨å™¨ç”µè·¯å®ç° (8åˆ†)
**é¢˜ç›®ï¼š** ä»…ä½¿ç”¨ANDã€NANDã€ORã€NORé—¨å’Œåç›¸å™¨å®ç°ç»™å®šçš„å¤šè·¯å¤ç”¨å™¨ç”µè·¯
**[English]** Implement the given multiplexer circuit using only AND, NAND, OR, NOR gates and inverters

**ç¬¦å·ï¼š**
```
     x â”€â”€â”€ 0 â”€â”¬â”€ 0 â”€â”
     y â”€â”€â”€ 1 â”€â”¤     â”œâ”€ q
     z â”€â”€â”€â”€â”€â”€â”€â”´â”€ 1 â”€â”˜
     a0
     a1
```

**é€»è¾‘æ–¹ç¨‹ï¼š**
```
q = (not a1 and not a0 and x) or 
    (not a1 and a0 and y) or 
    (a1 and z)
```

ç®€åŒ–ä¸ºï¼š
```
q = (not a1 and ((not a0 and x) or (a0 and y))) or (a1 and z)
```

---

## ç¬¬6é¢˜ - å¤šè·¯å¤ç”¨å™¨VHDLæè¿° (6åˆ†)
**é¢˜ç›®ï¼š** ç”¨æœ€ç®€å•çš„VHDLæè¿°ç¬¬5é¢˜ç”µè·¯
**[English]** Describe the circuit from question 5 in simplest VHDL

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity yyy is 
  port(x, y, z, a1, a0: in std_logic; 
       q: out std_logic);
end entity;
architecture dataflow of yyy is
begin
  q <= z when a1='1' else
       y when a0='1' else
       x;
end architecture;
```

---

## ç¬¬7é¢˜ - åˆ†æ”¯é¢„æµ‹å™¨ (6åˆ†)
> ğŸ›‘ **éè€ƒç‚¹æç¤º (Not on Exam):** æ ¹æ®2026å¹´è€ƒè¯•è¯´æ˜ï¼Œåˆ†æ”¯é¢„æµ‹å™¨è®¡ç®—é¢˜æœ¬æ¬¡ä¸è€ƒï¼Œå¯æˆ˜ç•¥æ€§è·³è¿‡ã€‚

**é¢˜ç›®ï¼š** Cç¨‹åºåœ¨æ•°ç»„ä¸­æŸ¥æ‰¾æœ€å°å€¼ï¼Œå‡è®¾forå¾ªç¯ç¼–è¯‘ä¸ºdo-whileï¼Œè®¡ç®—é”™è¯¯é¢„æµ‹æ¬¡æ•°ï¼š
**[English]** C program finds minimum in array, assuming for-loop compiled as do-while, calculate misprediction count:

```c
int data[] = { 0, 1, 2, 3, 4, -5, -6, -7, 8, 9 };
int min = INT_MAX;
for (int i = 0; i < sizeof(data)/sizeof(int); i++)
{ 
  if (data[i] < min) min = data[i];
}
```

**ç­”æ¡ˆï¼š**
- 1ä½é¢„æµ‹å™¨ï¼ˆåˆå§‹Not-Takenï¼‰: misses = ?
- 2ä½é¢„æµ‹å™¨ï¼ˆåˆå§‹Weakly Takenï¼‰: misses = ?

---

## ç¬¬8é¢˜ - Cacheè®¡ç®— (10åˆ†)
> ğŸ›‘ **éè€ƒç‚¹æç¤º (Not on Exam):** æ ¹æ®2026å¹´è€ƒè¯•è¯´æ˜ï¼ŒCacheæœªå‘½ä¸­è®¡ç®—é¢˜æœ¬æ¬¡ä¸è€ƒï¼Œå¯æˆ˜ç•¥æ€§è·³è¿‡ã€‚

**é¢˜ç›®ï¼š** 32ä½å¤„ç†å™¨ï¼Œcacheä»…128å­—èŠ‚ï¼Œ2è·¯ç»„ç›¸è”ï¼Œè¡Œé•¿1å­—ï¼Œä½¿ç”¨LRUæ›¿æ¢ç®—æ³•
**[English]** 32-bit processor, cache only 128 bytes, 2-way set associative, line size 1 word, using LRU replacement

è®¿é—®åºåˆ—ï¼š0x14, 0x94, 0x14, 0x94, 0x114, 0x14

**Cacheå‚æ•°ï¼š**
- 32ä½å¤„ç†å™¨ï¼šå­— = 4å­—èŠ‚
- è¡Œé•¿1å­— = 4å­—èŠ‚
- 128å­—èŠ‚ / 4å­—èŠ‚ = 32è¡Œ
- 2è·¯ç»„ç›¸è”ï¼š32/2 = 16ç»„
- åœ°å€åˆ†è§£ï¼š
  - Offset: 2ä½ï¼ˆå­—èŠ‚åç§»ï¼‰
  - Set Index: 4ä½ï¼ˆ16ç»„ï¼‰
  - Tag: å‰©ä½™ä½

---

## ç¬¬9é¢˜ - é™„åŠ é¢˜ï¼š3ä½Johnsonè®¡æ•°å™¨ (10åˆ†)
**é¢˜ç›®ï¼š** å®ç°3ä½åŒæ­¥Johnsonè®¡æ•°å™¨
**[English]** Implement a 3-bit synchronous Johnson counter
- RESET='1'æ—¶Q="000"
- DN=0æ—¶æ­£å‘è®¡æ•°ï¼š000,001,011,111,110,100,000...
- DN=1æ—¶åå‘è®¡æ•°

```vhdl
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity JC3 is 
  port (clk, DN, RESET: in std_logic;
        Q: out std_logic_vector(2 downto 0));
end entity;
architecture rtl of JC3 is
  signal q_int : std_logic_vector(2 downto 0) := "000";
begin
  process(clk)
  begin
    if rising_edge(clk) then
      if RESET = '1' then
        q_int <= "000";
      elsif DN = '0' then
        q_int <= q_int(1 downto 0) & (not q_int(2));
      else
        q_int <= (not q_int(0)) & q_int(2 downto 1);
      end if;
    end if;
  end process;
  Q <= q_int;
end architecture;
```

---

## çŸ¥è¯†ç‚¹æ€»ç»“

### æœ¬æ¬¡è€ƒè¯•é‡ç‚¹
1. RSé”å­˜å™¨ä»¿çœŸ
2. Shannonå±•å¼€
3. ç­‰ä»·é€»è¾‘å‡½æ•°
4. **VHDLå‡½æ•°ç¼–å†™**ï¼ˆå¿«é€Ÿå¹³å‡å€¼ï¼‰
5. å¤šè·¯å¤ç”¨å™¨ç”µè·¯å®ç°
6. å¤šè·¯å¤ç”¨å™¨VHDLæè¿°
7. **åˆ†æ”¯é¢„æµ‹å™¨è®¡ç®—**ï¼ˆé‡è¦ï¼ï¼‰
8. **Cacheè®¡ç®—**ï¼ˆ2è·¯ç»„ç›¸è”ï¼‰
9. Johnsonè®¡æ•°å™¨è®¾è®¡
