# 2025-06-09 LSP Exam Solution / Å˜eÅ¡enÃ­ zkouÅ¡ky / è€ƒè¯•è§£æ

> **Course**: B0B35LSP - LogickÃ© systÃ©my a procesory | BE5B35LSP - Logic Systems and Processors
> **University**: ÄŒVUT FEL (CTU) - Czech Technical University in Prague
> **Keywords**: ZkouÅ¡ka, Exam, Test, Solutions, Vysledky, Answers, K-Map, RS Latch, Pipeline
>
> [ğŸ‡¨ğŸ‡³ CN Version](./2025-06-09_Exam_CN.md) | [ğŸ‡¬ğŸ‡§ EN Version](./2025-06-09_Exam_EN.md) | [ğŸ‡¨ğŸ‡¿ CZ Version](./2025-06-09_Exam_CZ.md)

---

# ZkouÅ¡ka LSP â€” 2025-06-09

## Informace o zkouÅ¡ce
- Datum: 2025-06-09
- Jazyk: ÄeÅ¡tina (zdroj)
- Typ: standardnÃ­ zkouÅ¡ka
- âœ… OficiÃ¡lnÃ­ odpovÄ›di ovÄ›Å™eny podle PDF

---

## Ãšloha 1 â€” simulace RS zÃ¡chytnÃ©ho obvodu (5)
**ZadÃ¡nÃ­:** Vstupy A, B, C majÃ­ v Äasech $t_0..t_4$ hodnoty podle obrÃ¡zku. UrÄete hodnoty vÃ½stupÅ¯ X a Y.

**Sekvence vstupÅ¯:**
```
A = 1 | 1 | 1 | 0 | 1
B = 1 | 1 | 0 | 1 | 1
C = 0 | 1 | 0 | 0 | 0
    t0  t1  t2  t3  t4
```

**OficiÃ¡lnÃ­ odpovÄ›Ä:**
```
X = 0 | 0 | 1 | 1 | 0   (binÃ¡rnÄ›: 00110)
Y = 1 | 0 | 0 | 0 | 1   (binÃ¡rnÄ›: 10011)
```

PoznÃ¡mka: postupujte krok po kroku pÅ™es $t_0..t_4$ dle RS chovÃ¡nÃ­ a priority reset/set v konkrÃ©tnÃ­m zapojenÃ­ na zadÃ¡nÃ­.

---

## Ãšloha 2 â€” ShannonÅ¯v rozvoj (6)
**ZadÃ¡nÃ­:** RozloÅ¾te zpÄ›tnovazebnÃ­ funkci $X=f(A,B,C,X)$ z Ãºlohy 1 do tvaru:

$$X=(\lnot X\land f_0(A,B,C))\;\lor\;(X\land f_1(A,B,C)).$$

**OficiÃ¡lnÃ­ odpovÄ›Ä (K-map na testu):**

```
f0:     B                    f1:     B
       A  0  1                      A  0  1
C 0  â”‚ 0 â”‚ 0 â”‚ 1 â”‚ 0     C 0  â”‚ 1 â”‚ 0 â”‚ 1 â”‚ 0
  1  â”‚ 1 â”‚ 0 â”‚ 0 â”‚ 0       1  â”‚ 1 â”‚ 0 â”‚ 1 â”‚ 0
```

**OficiÃ¡lnÃ­ vÃ½raz (jak je uvedeno):**
```
X = (not C and B and A) or (C and not B and not A)
    or (X and not B and not A) or (X and B and A)
```

---

## Ãšloha 3 â€” ekvivalentnÃ­ logickÃ© funkce (4)
**ZadÃ¡nÃ­:** ZakrouÅ¾kujte vÅ¡echny logickÃ© funkce, kterÃ© majÃ­ v seznamu jinou ekvivalentnÃ­ funkci.

```vhdl
y1 <= (A or D) and (not A or C);
y2 <= C or (A and C and B) or (not A and C and D);
y3 <= (not A and D) or (A and not D) or (C and D);
y4 <= (C and D) or (not A xor not D);
```

**OficiÃ¡lnÃ­ odpovÄ›Ä:** $y3 \equiv y4$.

---

## Ãšloha 4 â€” aritmetika v 8bit registru (2)
**ZadÃ¡nÃ­:** UloÅ¾te niÅ¾Å¡Ã­ bity souÄtu $124+125+126+127$ do 1-bajtovÃ©ho registru. JakÃ¡ je decimÃ¡lnÃ­ hodnota jako 8bitovÃ© ÄÃ­slo?

VÃ½poÄet:
```
124 + 125 + 126 + 127 = 502
502 mod 256 = 246
```

OdpovÄ›Ä:
- Unsigned: 246
- Signed: -10 (protoÅ¾e $246-256=-10$)

---

## Ãšloha 5 â€” definice Moore/Mealy automatu (3)
**ZadÃ¡nÃ­:** DoplÅˆte definici (matematicky pÅ™esnÄ›).

MooreÅ¯v (Mealyho) automat je uspoÅ™Ã¡danÃ¡ Å¡estice:

$$M = \langle X, S, Z, \omega, \delta, s_0\in S \rangle.$$

- $X$ je koneÄnÃ¡ vstupnÃ­ abeceda
- $S$ je koneÄnÃ¡ mnoÅ¾ina stavÅ¯
- $Z$ je koneÄnÃ¡ vÃ½stupnÃ­ abeceda
- $\delta$ je pÅ™echodovÃ¡ funkce:
  - Moore: $\delta: S\times X \to S$
  - Mealy: $\delta: S\times X \to S$
- $\omega$ je vÃ½stupnÃ­ funkce:
  - Moore: $\omega: S \to Z$
  - Mealy: $\omega: S\times X \to Z$
- $s_0$ je poÄÃ¡teÄnÃ­ stav

---

## Ãšloha 6 â€” realizace +1 sÄÃ­taÄky (7)
**ZadÃ¡nÃ­:** NavrhnÄ›te +1 inkrementor pomocÃ­ hradel (bez plnÃ©ho sÄÃ­taÄe).

TypickÃ½ 4bit inkrementor:
- $s_0 = \lnot x_0$
- $s_1 = x_1 \oplus x_0$
- $s_2 = x_2 \oplus (x_0 \land x_1)$
- $s_3 = x_3 \oplus (x_0 \land x_1 \land x_2)$
- $carry = x_0 \land x_1 \land x_2 \land x_3$

---

## Ãšloha 7 â€” VHDL bitovÃ© operace (7)
**ZadÃ¡nÃ­:** PopiÅ¡te obvod optimÃ¡lnÄ› pomocÃ­ *konkurenÄnÃ­ho* VHDL (bez sekvenÄnÃ­ch pÅ™Ã­kazÅ¯). PlnÃ½ poÄet bodÅ¯ za jedinÃ½ pÅ™Ã­kaz v architektuÅ™e.

```vhdl
library ieee; use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity Test20250609q7 is 
  port(x: in std_logic_vector(3 downto 0);
       y: out std_logic_vector(3 downto 0));
end entity;
architecture rtl of Test20250609q7 is
begin
  y <= x and (x(2 downto 0) & '1');
end architecture rtl;
```

---

## Ãšloha 8 â€” analÃ½za VHDL obvodu (7+1)
**ZadÃ¡nÃ­:** Nakreslete blokovÃ© schÃ©ma pro obvod popsanÃ½ nÃ¡sledujÃ­cÃ­m kÃ³dem (hradla, MUX, +1 sÄÃ­taÄka, komparÃ¡tor, DFF).

```vhdl
library ieee; use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity Ex20250609q7 is 
  port (CLK : in std_logic; Q : out std_logic);
end entity;
architecture rtl1 of Ex20250609q7 is
begin
  iproc: process(CLK)
    constant M: integer := 9;
    variable cntr : integer range 0 to M := 0;
    variable x : std_logic := '0';
  begin
    if rising_edge(CLK) then
      if cntr < M then 
        cntr := cntr + 1; 
      else 
        cntr := 0; 
        x := not x;
      end if;
    end if;
    Q <= x;
  end process;
end architecture;
```

**Interpretace:** dÄ›liÄka frekvence / modulo-10 ÄÃ­taÄ s pÅ™eklÃ¡pÄ›nÃ­m vÃ½stupu.

---

## Ãšloha 9 â€” predikce skokÅ¯ (8)
Pozn.: V CN verzi je poznÃ¡mka, Å¾e v kontextu 2026-01 to â€nenÃ­ na zkouÅ¡kuâ€œ, ale pÅ¯vodnÃ­ Ãºloha je zde ponechÃ¡na pro Ãºplnost.

**ZadÃ¡nÃ­:** Pro nÃ¡sledujÃ­cÃ­ kÃ³d (pÅ™edpoklad: `for` je pÅ™eloÅ¾en jako `do-while`) spoÄÃ­tejte poÄet chybnÃ½ch predikcÃ­ pro uvedenÃ© prediktory.

```c
int data[] = { 0, 1, -2, -3, 4, -5, 6, -7, -8, 9 };
int min = INT_MAX;
for (int i = 0; i < 10; i++) {
  if (data[i] < min) min = data[i];
}
```

**OficiÃ¡lnÃ­ odpovÄ›Ä (podle CN master):**
- 1bit prediktor (poÄÃ¡teÄnÃ­ NT): misses = 9 (if 7 + smyÄka 2)
- 2bit prediktor (poÄÃ¡teÄnÃ­ WT): misses = 7 (if 6 + smyÄka 1)

NÃ¡Ärt prÅ¯bÄ›hu (poznÃ¡mky):
```
Branch: N  T  N  N  T  N  T  N  N  T
Data:   0  1 -2 -3  4 -5  6 -7 -8  9
```
